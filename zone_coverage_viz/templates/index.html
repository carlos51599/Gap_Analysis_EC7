<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Zone Coverage Visualization</title>
    
    <!-- Leaflet CSS -->
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
    
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
        }
        
        #map {
            width: 100%;
            height: 100vh;
            background: #f5f5f5;
        }
        
        .info-panel {
            position: absolute;
            top: 10px;
            right: 10px;
            z-index: 1000;
            background: white;
            padding: 15px;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.2);
            max-width: 300px;
            font-size: 14px;
        }
        
        .info-panel h3 {
            margin-bottom: 10px;
            color: #333;
        }
        
        .info-panel .stat {
            display: flex;
            justify-content: space-between;
            margin-bottom: 5px;
        }
        
        .info-panel .stat-label {
            color: #666;
        }
        
        .info-panel .stat-value {
            font-weight: bold;
            color: #333;
        }
        
        .info-panel .divider {
            border-top: 1px solid #eee;
            margin: 10px 0;
        }
        
        .zone-legend {
            margin-top: 10px;
        }
        
        .zone-legend-item {
            display: flex;
            align-items: center;
            margin-bottom: 5px;
        }
        
        .zone-legend-color {
            width: 16px;
            height: 16px;
            margin-right: 8px;
            border-radius: 3px;
        }
        
        .loading-overlay {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(255,255,255,0.9);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 2000;
        }
        
        .loading-spinner {
            text-align: center;
        }
        
        .loading-spinner .spinner {
            width: 40px;
            height: 40px;
            border: 4px solid #f3f3f3;
            border-top: 4px solid #3498db;
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin: 0 auto 10px;
        }
        
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        
        .toggle-row {
            margin: 5px 0;
        }
        
        .toggle-label {
            display: flex;
            align-items: center;
            cursor: pointer;
            font-size: 13px;
        }
        
        .toggle-label input {
            margin-right: 8px;
            cursor: pointer;
        }
        
        .action-buttons {
            margin-top: 10px;
            display: flex;
            gap: 8px;
            flex-wrap: wrap;
        }
        
        .action-btn {
            padding: 8px 12px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 12px;
            font-weight: 500;
            transition: background 0.2s, opacity 0.2s;
        }
        
        .action-btn:hover {
            opacity: 0.9;
        }
        
        .action-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }
        
        .btn-undo {
            background: #95a5a6;
            color: white;
        }
        
        .btn-add {
            background: #27ae60;
            color: white;
        }
        
        .btn-add.active {
            background: #e74c3c;
        }
        
        .btn-reset {
            background: #3498db;
            color: white;
        }
        
        .btn-export {
            background: #9b59b6;
            color: white;
            width: 100%;
        }
        
        .btn-delete-outside {
            background: #e67e22;
            color: white;
            width: 100%;
        }
        
        .add-mode-indicator {
            position: absolute;
            top: 50px;
            left: 50%;
            transform: translateX(-50%);
            background: #27ae60;
            color: white;
            padding: 10px 20px;
            border-radius: 20px;
            font-size: 14px;
            font-weight: bold;
            z-index: 1000;
            box-shadow: 0 2px 10px rgba(0,0,0,0.3);
            display: none;
        }
        
        .help-text {
            font-size: 11px;
            color: #888;
            margin-top: 8px;
            line-height: 1.4;
        }
        
        .delete-hint {
            display: block;
            width: 100%;
            background: #e74c3c;
            color: white;
            padding: 6px 12px;
            border-radius: 20px;
            font-size: 11px;
            font-weight: 500;
            text-align: center;
            box-sizing: border-box;
        }
        
        .coverage-stats {
            margin-top: 10px;
            padding: 10px;
            background: white;
            border-radius: 6px;
        }
        
        .coverage-stats h4 {
            margin: 0 0 8px 0;
            font-size: 12px;
            color: #333;
        }
        
        .coverage-stats .stat-row {
            display: flex;
            align-items: center;
            margin-bottom: 6px;
            font-size: 13px;
            gap: 8px;
        }
        
        .coverage-stats .zone-checkbox {
            width: 14px;
            height: 14px;
            cursor: pointer;
            flex-shrink: 0;
        }
        
        .coverage-stats .zone-name {
            color: #333;
            flex: 1;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }
        
        .coverage-stats .pct-value {
            font-weight: bold;
            min-width: 45px;
            text-align: right;
            flex-shrink: 0;
        }
        
        .coverage-stats .pct-good { color: #27ae60; }
        .coverage-stats .pct-medium { color: #f39c12; }
        .coverage-stats .pct-poor { color: #e74c3c; }
        
        /* Hidden zone styling - greyed out appearance */
        .coverage-stats .stat-row.hidden-zone {
            opacity: 0.5;
        }
        .coverage-stats .stat-row.hidden-zone .progress-fill {
            background: #999 !important;
        }
        .coverage-stats .stat-row.hidden-zone .pct-value {
            color: #999 !important;
        }
        .coverage-stats .stat-row.hidden-zone .zone-name {
            color: #999;
        }
        
        /* Group header with hidden zones - grey out the percentage */
        .coverage-stats .group-header.partial-hidden .group-pct {
            color: #999 !important;
        }
        
        /* Total row when any zones hidden */
        .coverage-stats .total-row.partial-hidden {
            opacity: 0.7;
        }
        .coverage-stats .total-row.partial-hidden .progress-fill {
            background: #999 !important;
        }
        .coverage-stats .total-row.partial-hidden .pct-value {
            color: #999 !important;
        }
        
        .coverage-stats .progress-bar {
            width: var(--coverage-progress-bar-width, 100px);
            flex-shrink: 0;
            height: 6px;
            background: #e0e0e0;
            border-radius: 3px;
            margin: 0 8px;
            overflow: hidden;
        }
        
        .coverage-stats .progress-fill {
            height: 100%;
            border-radius: 3px;
            transition: width 0.3s ease;
        }
        
        .coverage-stats .total-row {
            border-top: 1px solid #ddd;
            padding-top: 8px;
            margin-top: 8px;
            font-weight: bold;
        }
        
        .coverage-stats .total-row .progress-bar {
            flex: 1;
            width: auto;
        }
        
        /* Hierarchical zone groups */
        .coverage-stats .zone-group {
            margin-bottom: 6px;
        }
        
        .coverage-stats .group-header {
            display: flex;
            align-items: center;
            gap: 6px;
            cursor: pointer;
            padding: 4px 0;
            font-weight: bold;
            color: #333;
            user-select: none;
        }
        
        .coverage-stats .group-header:hover {
            background: #f5f5f5;
            border-radius: 3px;
        }
        
        .coverage-stats .group-toggle {
            width: 16px;
            height: 16px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 10px;
            color: #666;
            flex-shrink: 0;
            transition: transform 0.15s ease;
        }
        
        .coverage-stats .group-toggle.collapsed {
            transform: rotate(-90deg);
        }
        
        .coverage-stats .group-checkbox {
            width: 14px;
            height: 14px;
            cursor: pointer;
            flex-shrink: 0;
        }
        
        .coverage-stats .group-name {
            flex: 1;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }
        
        .coverage-stats .group-pct {
            font-weight: bold;
            min-width: 45px;
            text-align: right;
            flex-shrink: 0;
        }
        
        .coverage-stats .group-children {
            margin-left: 22px;
            overflow: hidden;
            transition: max-height 0.2s ease;
        }
        
        .coverage-stats .group-children.collapsed {
            max-height: 0 !important;
        }
        
        .coverage-stats .group-children .stat-row {
            font-size: 12px;
        }
        
        .coverage-stats .group-children .zone-name {
            font-weight: normal;
        }
        
        .data-timestamp {
            font-size: 10px;
            color: #888;
            margin-top: 8px;
            padding-top: 6px;
            border-top: 1px solid #eee;
        }
        
        /* ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
           LEFT PANEL - Coverage by Zone (collapsible)
           ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê */
        
        .left-panel {
            position: absolute;
            top: 10px;
            left: 10px;
            z-index: 1000;
            background: white;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.2);
            width: var(--coverage-panel-width, 320px);
            font-size: 14px;
            transition: transform 0.3s ease, opacity 0.3s ease;
        }
        
        .left-panel.collapsed {
            transform: translateX(-100%);
            opacity: 0;
            pointer-events: none;
        }
        
        .left-panel-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 12px 15px;
            border-bottom: 1px solid #eee;
            background: white;
            border-radius: 8px 8px 0 0;
        }
        
        .left-panel-header h4 {
            margin: 0;
            font-size: 14px;
            color: #333;
        }
        
        .left-panel-content {
            padding: 15px;
            max-height: calc(100vh - 150px);
            overflow-y: auto;
        }
        
        .panel-toggle-btn {
            position: absolute;
            top: 10px;
            left: 10px;
            z-index: 1001;
            width: 32px;
            height: 32px;
            background: white;
            border: none;
            border-radius: 6px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.2);
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 14px;
            transition: transform 0.3s ease, left 0.3s ease;
        }
        
        .panel-toggle-btn:hover {
            background: #f5f5f5;
        }
        
        .panel-toggle-btn.panel-open {
            left: calc(var(--coverage-panel-width, 320px) + 15px);  /* Position next to expanded panel */
        }
        
        .panel-toggle-btn .arrow {
            transition: transform 0.3s ease;
        }
        
        .panel-toggle-btn.panel-open .arrow {
            transform: rotate(180deg);
        }
        
        /* Focus outline disabled via JavaScript when CONFIG.ui.show_zone_focus_outline === false */
    </style>
</head>
<body>
    <div id="map"></div>
    
    <!-- Left Panel Toggle Button -->
    <button class="panel-toggle-btn panel-open" id="leftPanelToggle" title="Toggle Coverage Panel">
        <span class="arrow">‚ñ∂</span>
    </button>
    
    <!-- Left Panel - Coverage by Zone -->
    <div class="left-panel" id="leftPanel">
        <div class="left-panel-header">
            <h4>Coverage by Zone</h4>
        </div>
        <div class="left-panel-content coverage-stats">
            <div id="coverageStatsContent">
                <span style="color: #888; font-size: 11px;">Loading...</span>
            </div>
            <div class="data-timestamp" id="dataTimestamp"></div>
        </div>
    </div>
    
    <div class="add-mode-indicator" id="addModeIndicator">
        üìç Click on map to add borehole (ESC to cancel)
    </div>
    
    <div class="info-panel" id="infoPanel">
        <h3>Overview</h3>
        <div class="stat">
            <span class="stat-label">Boreholes:</span>
            <span class="stat-value" id="boreholeCount">-</span>
        </div>
        <div class="stat">
            <span class="stat-label">Zones:</span>
            <span class="stat-value" id="zoneCount">-</span>
        </div>
        <div class="divider"></div>
        <div class="action-buttons">
            <button class="action-btn btn-undo" id="undoBtn" disabled title="Undo last action">
                ‚Ü© Undo
            </button>
            <button class="action-btn btn-add" id="addBoreholeBtn" title="Add new borehole">
                + Add Borehole
            </button>
            <button class="action-btn btn-reset" id="resetBtn" title="Reset to original positions">
                ‚ü≤ Reset
            </button>
        </div>
        <div class="help-text">
            <span class="delete-hint">Shift+Click on borehole to delete</span>
        </div>
        <div class="divider"></div>
        <div class="toggle-row">
            <label class="toggle-label">
                <input type="checkbox" id="toggleBaseMap" checked>
                <span>Show Background Map</span>
            </label>
        </div>
        <div class="divider"></div>
        <div id="selectedBorehole" style="display: none;">
            <h4 style="margin-bottom: 5px;">Selected Borehole</h4>
            <div class="stat">
                <span class="stat-label">ID:</span>
                <span class="stat-value" id="selectedId">-</span>
            </div>
            <div class="stat">
                <span class="stat-label">Zone:</span>
                <span class="stat-value" id="selectedZone">-</span>
            </div>
            <div class="stat">
                <span class="stat-label">Radius:</span>
                <span class="stat-value" id="selectedRadius">-</span>
            </div>
        </div>
        <div class="divider"></div>
        <div class="action-buttons">
            <button class="action-btn btn-delete-outside" id="deleteOutsideBtn" title="Delete all boreholes outside zones (orange markers)">
                üóëÔ∏è Delete Outside Boreholes
            </button>
        </div>
        <div class="action-buttons">
            <button class="action-btn btn-export" id="exportCsvBtn" title="Export borehole coordinates to CSV">
                üì• Export CSV
            </button>
        </div>
    </div>
    
    <div class="loading-overlay" id="loadingOverlay">
        <div class="loading-spinner">
            <div class="spinner"></div>
            <div>Loading data...</div>
        </div>
    </div>
    
    <!-- Leaflet JS -->
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
    
    <script>
        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        // ÔøΩ CONFIGURATION (loaded from server)
        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        
        let CONFIG = null;  // Loaded from /api/config at startup
        
        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        // üó∫Ô∏è MAP INITIALIZATION
        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        
        // Initialize map (centered on UK) - will be re-centered after data loads
        const map = L.map('map', { zoomControl: false }).setView([51.5, -1.0], 14);
        
        // Add base layer (OpenStreetMap) with very reduced opacity
        const baseLayer = L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
            attribution: '&copy; OpenStreetMap contributors',
            opacity: 0.25
        }).addTo(map);
        
        // Layer groups - initialized with default styles, updated after config loads
        let zonesLayer = L.geoJSON(null, {
            style: {
                color: '#666666',
                weight: 3,
                opacity: 0.8,
                fillColor: '#ffffff',
                fillOpacity: 1
            },
            interactive: true,  // Enable interaction for tooltips
            onEachFeature: (feature, layer) => {
                const props = feature.properties || {};
                const zoneName = props.zone_name || props.display_name || 'Zone';
                // Bind tooltip if enabled in config (default: true, check after CONFIG loads)
                // Note: CONFIG is not available yet, so we bind and may unbind later in applyConfig()
                layer.bindTooltip(zoneName, {
                    permanent: false,
                    sticky: true,  // Follow the cursor
                    className: 'zone-tooltip'
                });
                // Store zone name for later reference
                layer.zoneName = zoneName;
                // Prevent click from showing bounding box - instead highlight actual geometry
                layer.on('click', (e) => {
                    L.DomEvent.stopPropagation(e);  // Don't propagate to map
                });
            }
        });
        
        // Existing borehole coverage (green, below proposed)
        // Note: Style will be updated from CONFIG after data is loaded in renderExistingCoverage()
        const existingCoverageLayer = L.geoJSON(null, {
            style: {
                color: '#27ae60',
                weight: 2,
                opacity: 0.8,
                fillColor: '#5feb5f',  // Matches ec7_coverage.html: rgba(95, 235, 95, 0.85)
                fillOpacity: 0.85
            },
            interactive: false  // Let mouse events pass through to boreholes
        });
        
        const coverageLayer = L.geoJSON(null, {
            style: {
                color: '#2980b9',
                weight: 3,
                opacity: 0.8,
                fillColor: '#3498db',
                fillOpacity: 0.25
            },
            interactive: false  // Let mouse events pass through to boreholes
        });
        
        const boreholesLayer = L.layerGroup();
        
        // Add layers to map in order (zones at bottom, existing coverage, proposed coverage, boreholes on top)
        zonesLayer.addTo(map);
        existingCoverageLayer.addTo(map);
        coverageLayer.addTo(map);
        boreholesLayer.addTo(map);

        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        // üìä DATA STORAGE
        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        
        let boreholeMarkers = [];
        let zonesData = null;
        let boreholesData = null;
        let originalBoreholesData = null;  // Store initial state for reset
        
        // Zone visibility state: { "zone_name": true/false }
        let zoneVisibility = {};
        
        // NOTE: We no longer use hiddenBoreholesPerZone - zone associations are
        // pre-computed by server as zone_ids in each borehole's properties.
        // This is the single source of truth for zone-borehole relationships.
        
        // Undo history stack
        let undoHistory = [];
        const MAX_UNDO_HISTORY = 50;
        
        // Add borehole mode
        let addBoreholeMode = false;
        
        // Zone colors
        // Zone colors - loaded from config, fallback here
        let zoneColors = {
            'Embankment': '#e74c3c',
            'Highways': '#3498db'
        };
        
        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        // üéØ VISIBILITY HELPERS (Generic for any future filters)
        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        // 
        // IMPORTANT FOR FUTURE DEVELOPERS:
        // These helpers detect visible boreholes by checking if markers are on the map.
        // To ensure your filter works with the borehole count and CSV export:
        //
        // ‚úÖ CORRECT - Use Leaflet layer management:
        //    To hide: markerGroup.remove() OR boreholesLayer.removeLayer(markerGroup)
        //    To show: boreholesLayer.addLayer(markerGroup)
        //
        // ‚ùå WRONG - These approaches will NOT work:
        //    - CSS visibility (opacity: 0, display: none)
        //    - Moving markers off-screen
        //    - Separate tracking without layer removal
        //
        // Zone visibility uses pre-computed zone_ids from server (single source of truth).
        // See toggleZoneVisibility() for reference implementation.
        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        
        /**
         * Get indices of all currently visible boreholes on the map.
         * This is filter-agnostic - works with any current or future filtering mechanism.
         * @returns {number[]} Array of visible borehole indices
         */
        function getVisibleBoreholeIndices() {
            const visibleIndices = [];
            boreholeMarkers.forEach((grabCircle) => {
                // Check if the marker's group is actually on the map
                if (grabCircle.markerGroup && map.hasLayer(grabCircle.markerGroup)) {
                    visibleIndices.push(grabCircle.boreholeIndex);
                }
            });
            return visibleIndices;
        }
        
        /**
         * Get indices of all hidden boreholes (not on map).
         * @returns {number[]} Array of hidden borehole indices
         */
        function getHiddenBoreholeIndices() {
            const hiddenIndices = [];
            boreholeMarkers.forEach((grabCircle) => {
                if (!grabCircle.markerGroup || !map.hasLayer(grabCircle.markerGroup)) {
                    hiddenIndices.push(grabCircle.boreholeIndex);
                }
            });
            return hiddenIndices;
        }
        
        /**
         * Check if a borehole should be visible based on zone visibility state.
         * Uses pre-computed coverage_zone_ids (zones the buffer touches) from server.
         * 
         * Rule (R1): Borehole is VISIBLE if its coverage touches ANY visible zone.
         * This means a borehole in a hidden zone stays visible if its coverage
         * reaches into a visible zone.
         * 
         * @param {Array<string>} coverageZoneIds - Array of zone names the borehole's coverage touches
         * @returns {boolean} - True if borehole should be visible
         */
        function isBoreholeVisibleByZones(coverageZoneIds) {
            if (!coverageZoneIds || coverageZoneIds.length === 0) {
                return true; // Borehole coverage not touching any zone = always visible
            }
            // Visible if ANY zone in coverage is visible (not hidden)
            return coverageZoneIds.some(zid => zoneVisibility[zid] !== false);
        }
        
        /**
         * Update the borehole count display in the info panel.
         * Shows "visible/total" when filtered, or just "total" when all visible.
         */
        function updateBoreholeCountDisplay() {
            const totalCount = boreholeMarkers.length;
            const visibleCount = getVisibleBoreholeIndices().length;
            const countElement = document.getElementById('boreholeCount');
            
            if (countElement) {
                countElement.textContent = visibleCount === totalCount 
                    ? `${totalCount}` 
                    : `${visibleCount}/${totalCount}`;
            }
        }
        
        /**
         * Sync coverage zones from coverage layer to borehole markers.
         * Coverage features have properties.zones (zones the buffer touches).
         * This links that data to grabCircle.coverageZoneIds for visibility filtering.
         */
        function syncCoverageZonesToMarkers() {
            coverageLayer.eachLayer((layer) => {
                const props = layer.feature?.properties;
                if (props && props.borehole_index !== undefined && props.zones) {
                    const marker = boreholeMarkers.find(m => m.boreholeIndex === props.borehole_index);
                    if (marker) {
                        marker.coverageZoneIds = props.zones;
                    }
                }
            });
            console.log('üîó Coverage zones synced to borehole markers');
        }
        
        /**
         * Get list of currently hidden zone names.
         * Used for R2: excluding hidden zones when moving/adding boreholes.
         * @returns {string[]} Array of hidden zone names
         */
        function getHiddenZoneNames() {
            return Object.entries(zoneVisibility)
                .filter(([_, visible]) => visible === false)
                .map(([zoneName, _]) => zoneName);
        }
        
        /**
         * Get the zone visibility mode from config.
         * @returns {string} "clip_coverage" or "hide_zone_boreholes"
         */
        function getZoneVisibilityMode() {
            return CONFIG?.zoneVisibility?.mode || 'clip_coverage';
        }
        
        /**
         * Check if a borehole should be visible based on its LOCATION zone.
         * Used by "hide_zone_boreholes" mode - stricter than coverageZoneIds check.
         * 
         * Rule: Borehole is VISIBLE only if ALL its location zones are visible.
         * If a borehole is inside a hidden zone, it's hidden (even if coverage
         * extends to visible zones).
         * 
         * @param {Array<string>} locationZoneIds - Array of zone names the borehole is inside
         * @returns {boolean} - True if borehole should be visible
         */
        function isBoreholeVisibleByLocationZone(locationZoneIds) {
            if (!locationZoneIds || locationZoneIds.length === 0) {
                return true; // Borehole not inside any zone = always visible
            }
            // Hidden if ANY location zone is hidden
            return !locationZoneIds.some(zid => zoneVisibility[zid] === false);
        }

        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        // üîÑ API FUNCTIONS
        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        
        async function fetchConfig() {
            try {
                const response = await fetch('/api/config');
                const data = await response.json();
                return data;
            } catch (error) {
                console.error('Failed to fetch config:', error);
                return null;
            }
        }
        
        async function fetchDataInfo() {
            try {
                const response = await fetch('/api/data/info');
                const data = await response.json();
                return data;
            } catch (error) {
                console.error('Failed to fetch data info:', error);
                return null;
            }
        }
        
        async function fetchZones() {
            try {
                const response = await fetch('/api/zones');
                const data = await response.json();
                return data;
            } catch (error) {
                console.error('Failed to fetch zones:', error);
                return { type: 'FeatureCollection', features: [] };
            }
        }
        
        async function fetchBoreholes() {
            try {
                const response = await fetch('/api/boreholes');
                const data = await response.json();
                return data;
            } catch (error) {
                console.error('Failed to fetch boreholes:', error);
                return { type: 'FeatureCollection', features: [] };
            }
        }
        
        async function fetchAllCoverages() {
            try {
                const response = await fetch('/api/coverage/all');
                const data = await response.json();
                return data;
            } catch (error) {
                console.error('Failed to fetch coverages:', error);
                return { type: 'FeatureCollection', features: [] };
            }
        }
        
        /**
         * Fetch coverages clipped to exclude specified zones.
         * Server computes coverage based on mode (SSOT - server makes visibility decisions).
         * @param {string[]} excludeZones - Zone names to exclude
         * @param {string} mode - "clip_coverage" or "hide_zone_boreholes"
         * @returns {Object} GeoJSON FeatureCollection of coverage polygons
         */
        async function fetchFilteredCoverages(excludeZones, mode = 'clip_coverage') {
            const t_start = performance.now();
            try {
                const response = await fetch('/api/coverage/filtered', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ excludeZones, mode })
                });
                const data = await response.json();
                const t_end = performance.now();
                console.log(`üîÑ Filtered coverages fetched in ${(t_end - t_start).toFixed(1)}ms (mode: ${mode}, excluding ${excludeZones.length} zones)`);
                return data;
            } catch (error) {
                console.error('Failed to fetch filtered coverages:', error);
                return { type: 'FeatureCollection', features: [] };
            }
        }
        
        async function fetchExistingCoverage() {
            try {
                const response = await fetch('/api/existing-coverage');
                const data = await response.json();
                return data;
            } catch (error) {
                console.error('Failed to fetch existing coverage:', error);
                return { type: 'FeatureCollection', features: [] };
            }
        }
        
        /**
         * Fetch existing coverage clipped to visible zones (SSOT compliant).
         * Server clips the coverage polygon to exclude hidden zones.
         * @param {string[]} excludeZones - Zone names to exclude
         * @returns {Object} GeoJSON FeatureCollection of clipped existing coverage
         */
        async function fetchFilteredExistingCoverage(excludeZones) {
            const t_start = performance.now();
            try {
                const response = await fetch('/api/existing-coverage/filtered', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ excludeZones })
                });
                const data = await response.json();
                const t_end = performance.now();
                console.log(`üîÑ Filtered existing coverage fetched in ${(t_end - t_start).toFixed(1)}ms (excluding ${excludeZones.length} zones)`);
                return data;
            } catch (error) {
                console.error('Failed to fetch filtered existing coverage:', error);
                return { type: 'FeatureCollection', features: [] };
            }
        }
        
        async function fetchCoverageStats() {
            try {
                const response = await fetch('/api/coverage/stats');
                const data = await response.json();
                return data;
            } catch (error) {
                console.error('Failed to fetch coverage stats:', error);
                return null;
            }
        }
        
        async function updateBoreholePosition(index, lon, lat) {
            const t_start = performance.now();
            console.log(`üìç [MOVE] Starting update for borehole ${index} to (${lon.toFixed(6)}, ${lat.toFixed(6)})`);
            try {
                const hiddenZones = getHiddenZoneNames();  // R2: exclude hidden zones from zone_ids
                const t_fetch_start = performance.now();
                const response = await fetch('/api/coverage/update', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ index, lon, lat, excludeZones: hiddenZones })
                });
                const t_fetch_end = performance.now();
                console.log(`    [MOVE] Fetch: ${(t_fetch_end - t_fetch_start).toFixed(1)}ms (excludeZones: ${hiddenZones.length})`);
                
                const t_parse_start = performance.now();
                const data = await response.json();
                const t_parse_end = performance.now();
                console.log(`    [MOVE] Parse JSON: ${(t_parse_end - t_parse_start).toFixed(1)}ms`);
                
                const t_total = performance.now() - t_start;
                console.log(`‚úÖ [MOVE] Total: ${t_total.toFixed(1)}ms`);
                return data;
            } catch (error) {
                console.error('‚ùå [MOVE] Failed to update borehole:', error);
                return null;
            }
        }
        
        async function deleteBorehole(index) {
            const t_start = performance.now();
            console.log(`üóëÔ∏è [DELETE] Starting delete for borehole ${index}`);
            try {
                const t_fetch_start = performance.now();
                const response = await fetch('/api/borehole/delete', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ index })
                });
                const t_fetch_end = performance.now();
                console.log(`    [DELETE] Fetch: ${(t_fetch_end - t_fetch_start).toFixed(1)}ms`);
                
                const t_parse_start = performance.now();
                const data = await response.json();
                const t_parse_end = performance.now();
                console.log(`    [DELETE] Parse JSON: ${(t_parse_end - t_parse_start).toFixed(1)}ms`);
                
                const t_total = performance.now() - t_start;
                console.log(`‚úÖ [DELETE] Total API call: ${t_total.toFixed(1)}ms`);
                return data;
            } catch (error) {
                console.error('‚ùå [DELETE] Failed to delete borehole:', error);
                return null;
            }
        }
        
        async function restoreBoreholes(boreholesGeojson) {
            try {
                const response = await fetch('/api/borehole/restore', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ boreholes: boreholesGeojson })
                });
                const data = await response.json();
                return data;
            } catch (error) {
                console.error('Failed to restore boreholes:', error);
                return null;
            }
        }
        
        async function addNewBorehole(lon, lat, locationId = null) {
            try {
                const hiddenZones = getHiddenZoneNames();  // R2: exclude hidden zones from zone_ids
                const body = { lon, lat, excludeZones: hiddenZones };
                if (locationId) body.location_id = locationId;
                
                const response = await fetch('/api/borehole/add', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(body)
                });
                const data = await response.json();
                return data;
            } catch (error) {
                console.error('Failed to add borehole:', error);
                return null;
            }
        }
        
        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        // üîÑ UNDO SYSTEM
        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        
        function saveStateForUndo() {
            // Deep clone current boreholes data
            const snapshot = JSON.parse(JSON.stringify(boreholesData));
            undoHistory.push(snapshot);
            
            // Limit history size
            if (undoHistory.length > MAX_UNDO_HISTORY) {
                undoHistory.shift();
            }
            
            updateUndoButton();
        }
        
        function updateUndoButton() {
            const undoBtn = document.getElementById('undoBtn');
            undoBtn.disabled = undoHistory.length === 0;
        }
        
        async function performUndo() {
            if (undoHistory.length === 0) return;
            
            const previousState = undoHistory.pop();
            boreholesData = previousState;
            
            // Sync restored state to server
            await restoreBoreholes(boreholesData);
            
            // Re-render boreholes
            renderBoreholes(boreholesData);
            
            // Re-compute coverages (now server has correct state) - includes stats
            const coveragesResponse = await fetchAllCoverages();
            renderCoverages(coveragesResponse);
            
            // Sync coverage zones to markers (for visibility filtering)
            syncCoverageZonesToMarkers();
            
            // Re-apply zone visibility after re-rendering
            updateBoreholeVisibilityForZones();
            
            updateUndoButton();
            console.log('‚Ü©Ô∏è Undo performed');
            
            // Render coverage stats from response (avoids extra API call)
            if (coveragesResponse.stats) {
                renderCoverageStats(coveragesResponse.stats);
            }
        }
        
        async function performReset() {
            if (!originalBoreholesData) return;
            
            // Restore to original state
            boreholesData = JSON.parse(JSON.stringify(originalBoreholesData));
            
            // Sync restored state to server
            await restoreBoreholes(boreholesData);
            
            // Re-render boreholes
            renderBoreholes(boreholesData);
            
            // Re-compute coverages - includes stats
            const coveragesResponse = await fetchAllCoverages();
            renderCoverages(coveragesResponse);
            
            // Sync coverage zones to markers (for visibility filtering)
            syncCoverageZonesToMarkers();
            
            // Re-apply zone visibility after re-rendering
            updateBoreholeVisibilityForZones();
            
            // Clear undo history
            undoHistory = [];
            updateUndoButton();
            console.log('üîÑ Reset to original state');
            
            // Render coverage stats from response (avoids extra API call)
            if (coveragesResponse.stats) {
                renderCoverageStats(coveragesResponse.stats);
            }
        }
        
        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        // üé® RENDERING FUNCTIONS
        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        
        function getCoverageStatsConfig() {
            return (CONFIG && CONFIG.coverageStats) ? CONFIG.coverageStats : {
                good_threshold: 90,
                medium_threshold: 50,
                good_color: '#27ae60',
                medium_color: '#f39c12',
                poor_color: '#e74c3c'
            };
        }
        
        function getPctClass(pct) {
            const cfg = getCoverageStatsConfig();
            if (pct >= cfg.good_threshold) return 'pct-good';
            if (pct >= cfg.medium_threshold) return 'pct-medium';
            return 'pct-poor';
        }
        
        function getPctColor(pct) {
            const cfg = getCoverageStatsConfig();
            if (pct >= cfg.good_threshold) return cfg.good_color;
            if (pct >= cfg.medium_threshold) return cfg.medium_color;
            return cfg.poor_color;
        }
        
        async function refreshCoverageStats() {
            const stats = await fetchCoverageStats();
            if (!stats) return;
            renderCoverageStats(stats);
        }
        
        // Render coverage stats directly (avoids extra API call when stats provided in response)
        function renderCoverageStats(stats) {
            if (!stats) return;
            
            const container = document.getElementById('coverageStatsContent');
            
            // Initialize zone visibility for any new zones (default to visible)
            for (const zone of stats.per_zone) {
                if (zoneVisibility[zone.zone_name] === undefined) {
                    zoneVisibility[zone.zone_name] = true;
                }
            }
            
            // Group zones by layer_key for hierarchical display
            const groupedZones = {};
            for (const zone of stats.per_zone) {
                const layerKey = zone.layer_key || 'unknown';
                const displayName = zone.layer_display_name || layerKey.replace(/_/g, ' ');
                if (!groupedZones[layerKey]) {
                    groupedZones[layerKey] = {
                        displayName: displayName,
                        zones: [],
                        totalArea: 0,
                        coveredArea: 0
                    };
                }
                groupedZones[layerKey].zones.push(zone);
                groupedZones[layerKey].totalArea += zone.total_area_m2;
                groupedZones[layerKey].coveredArea += zone.covered_area_m2;
            }
            
            // Build HTML for hierarchical per-zone stats
            let html = '';
            
            for (const [layerKey, group] of Object.entries(groupedZones)) {
                // Calculate group coverage percentage
                const groupPct = group.totalArea > 0 
                    ? Math.round((group.coveredArea / group.totalArea) * 1000) / 10 
                    : 0;
                const groupPctClass = getPctClass(groupPct);
                const groupPctColor = getPctColor(groupPct);
                
                // Check if all zones in group are visible
                const allVisible = group.zones.every(z => zoneVisibility[z.zone_name] !== false);
                const someVisible = group.zones.some(z => zoneVisibility[z.zone_name] !== false);
                const partialHiddenClass = allVisible ? '' : 'partial-hidden';
                
                html += `
                    <div class="zone-group" data-layer="${layerKey}">
                        <div class="group-header ${partialHiddenClass}" onclick="toggleGroupExpand('${layerKey}')">
                            <span class="group-toggle" id="toggle-${layerKey}">‚ñº</span>
                            <input type="checkbox" class="group-checkbox" 
                                   data-layer="${layerKey}" 
                                   ${allVisible ? 'checked' : ''}
                                   ${!allVisible && someVisible ? 'indeterminate' : ''}
                                   onclick="event.stopPropagation(); toggleGroupVisibility('${layerKey}', this.checked)">
                            <span class="group-name">${group.displayName}</span>
                            <span class="group-pct ${groupPctClass}">${groupPct}%</span>
                        </div>
                        <div class="group-children" id="children-${layerKey}">
                `;
                
                for (const zone of group.zones) {
                    const pctClass = getPctClass(zone.coverage_pct);
                    const pctColor = getPctColor(zone.coverage_pct);
                    const isVisible = zoneVisibility[zone.zone_name] !== false;
                    const hiddenClass = isVisible ? '' : 'hidden-zone';
                    
                    // Extract just the zone number for display (e.g., "Embankment_0" -> "Zone 0")
                    const shortName = zone.zone_name.replace(/^.*_(\d+)$/, 'Zone $1');
                    
                    html += `
                        <div class="stat-row ${hiddenClass}"
                             data-zone="${zone.zone_name}">
                            <input type="checkbox" class="zone-checkbox" 
                                   data-zone="${zone.zone_name}"
                                   data-layer="${layerKey}"
                                   ${isVisible ? 'checked' : ''}
                                   onchange="toggleZoneVisibility('${zone.zone_name}', this.checked); updateGroupCheckbox('${layerKey}');">
                            <span class="zone-name" title="${zone.zone_name}">${shortName}</span>
                            <div class="progress-bar">
                                <div class="progress-fill" style="width: ${Math.min(zone.coverage_pct, 100)}%; background: ${pctColor};"></div>
                            </div>
                            <span class="pct-value ${pctClass}">${zone.coverage_pct}%</span>
                        </div>
                    `;
                }
                
                html += `
                        </div>
                    </div>
                `;
            }
            
            // Add total row (no checkbox for total)
            const totalPctClass = getPctClass(stats.total.coverage_pct);
            // Check if ANY zones are hidden - grey out total if so
            const anyZonesHidden = stats.per_zone.some(z => zoneVisibility[z.zone_name] === false);
            const totalHiddenClass = anyZonesHidden ? 'partial-hidden' : '';
            
            html += `
                <div class="stat-row total-row ${totalHiddenClass}">
                    <span class="zone-name" style="margin-left: 22px;">Total</span>
                    <div class="progress-bar">
                        <div class="progress-fill" style="width: ${Math.min(stats.total.coverage_pct, 100)}%; background: ${getPctColor(stats.total.coverage_pct)};"></div>
                    </div>
                    <span class="pct-value ${totalPctClass}">${stats.total.coverage_pct}%</span>
                </div>
            `;
            
            container.innerHTML = html;
            
            // Set indeterminate state on group checkboxes where applicable
            for (const [layerKey, group] of Object.entries(groupedZones)) {
                updateGroupCheckbox(layerKey);
            }
        }
        
        // Track group expansion state
        const groupExpanded = {};
        
        // Toggle group expand/collapse
        function toggleGroupExpand(layerKey) {
            const children = document.getElementById(`children-${layerKey}`);
            const toggle = document.getElementById(`toggle-${layerKey}`);
            
            if (!children || !toggle) return;
            
            const isExpanded = !children.classList.contains('collapsed');
            
            if (isExpanded) {
                children.classList.add('collapsed');
                toggle.classList.add('collapsed');
                groupExpanded[layerKey] = false;
            } else {
                children.classList.remove('collapsed');
                toggle.classList.remove('collapsed');
                groupExpanded[layerKey] = true;
            }
        }
        
        // Toggle all zones in a group at once (batch operation - single API call)
        async function toggleGroupVisibility(layerKey, visible) {
            console.log(`üîÑ Toggle group ${layerKey}: ${visible}`);
            const t_start = performance.now();
            const mode = getZoneVisibilityMode();
            
            // Find all zone checkboxes in this group
            const checkboxes = document.querySelectorAll(`.zone-checkbox[data-layer="${layerKey}"]`);
            
            // 1. Update all zones' state immediately (no API calls yet)
            checkboxes.forEach(cb => {
                const zoneName = cb.dataset.zone;
                cb.checked = visible;
                zoneVisibility[zoneName] = visible;
                
                // Update zone polygon opacity (instant)
                zonesLayer.eachLayer((layer) => {
                    const props = layer.feature?.properties;
                    if (props && (props.zone_name === zoneName || props.display_name === zoneName)) {
                        layer.setStyle(visible 
                            ? { opacity: 0.8, fillOpacity: 1 } 
                            : { opacity: 0, fillOpacity: 0 });
                    }
                });
                
                // Update stat-row styling
                const statRow = document.querySelector(`.stat-row[data-zone="${zoneName}"]`);
                if (statRow) {
                    statRow.classList.toggle('hidden-zone', !visible);
                }
            });
            
            // 2. Update borehole visibility based on mode
            boreholeMarkers.forEach((grabCircle) => {
                const markerGroup = grabCircle.markerGroup;
                let shouldBeVisible;
                
                if (mode === 'hide_zone_boreholes') {
                    const locationZoneIds = grabCircle.zoneIds || [];
                    shouldBeVisible = isBoreholeVisibleByLocationZone(locationZoneIds);
                } else {
                    const coverageZoneIds = grabCircle.coverageZoneIds || [];
                    shouldBeVisible = isBoreholeVisibleByZones(coverageZoneIds);
                }
                
                if (shouldBeVisible) {
                    if (!map.hasLayer(markerGroup)) {
                        boreholesLayer.addLayer(markerGroup);
                    }
                } else {
                    if (map.hasLayer(markerGroup)) {
                        markerGroup.remove();
                    }
                }
            });
            
            // 3. Make SINGLE API call with all current hidden zones
            const hiddenZones = getHiddenZoneNames();
            
            if (hiddenZones.length === 0) {
                const [coverages, existingCoverage] = await Promise.all([
                    fetchAllCoverages(),
                    fetchExistingCoverage()
                ]);
                renderCoverages(coverages);
                renderExistingCoverage(existingCoverage);
            } else {
                const [filteredCoverages, filteredExisting] = await Promise.all([
                    fetchFilteredCoverages(hiddenZones, mode),
                    fetchFilteredExistingCoverage(hiddenZones)
                ]);
                renderCoverages(filteredCoverages);
                renderExistingCoverage(filteredExisting);
            }
            
            // 4. Finalize
            syncCoverageZonesToMarkers();
            updateCoverageStatsGreyout();  // Update group and total greyout
            updateBoreholeCountDisplay();
            
            const t_end = performance.now();
            console.log(`‚úÖ Group toggle complete in ${(t_end - t_start).toFixed(1)}ms (mode: ${mode})`);
        }
        
        // Update group checkbox state based on children
        function updateGroupCheckbox(layerKey) {
            const groupCb = document.querySelector(`.group-checkbox[data-layer="${layerKey}"]`);
            const childCbs = document.querySelectorAll(`.zone-checkbox[data-layer="${layerKey}"]`);
            
            if (!groupCb || childCbs.length === 0) return;
            
            const checkedCount = Array.from(childCbs).filter(cb => cb.checked).length;
            
            if (checkedCount === 0) {
                groupCb.checked = false;
                groupCb.indeterminate = false;
            } else if (checkedCount === childCbs.length) {
                groupCb.checked = true;
                groupCb.indeterminate = false;
            } else {
                groupCb.checked = false;
                groupCb.indeterminate = true;
            }
        }
        
        // Toggle zone visibility - Supports two modes via config:
        // - "clip_coverage": Coverage polygons clipped to visible zones, boreholes visible if coverage touches visible zone
        // - "hide_zone_boreholes": Boreholes hidden if inside hidden zone, their entire coverage hidden too
        async function toggleZoneVisibility(zoneName, visible) {
            console.log(`üîÑ Toggle zone ${zoneName}: ${visible}`);
            const t_start = performance.now();
            const mode = getZoneVisibilityMode();
            
            // 1. Update state
            zoneVisibility[zoneName] = visible;
            
            // 2. Update zone polygon opacity (instant)
            zonesLayer.eachLayer((layer) => {
                const props = layer.feature?.properties;
                if (props && (props.zone_name === zoneName || props.display_name === zoneName)) {
                    if (visible) {
                        layer.setStyle({ opacity: 0.8, fillOpacity: 1 });
                    } else {
                        layer.setStyle({ opacity: 0, fillOpacity: 0 });
                    }
                }
            });
            
            // 3. Update borehole visibility based on mode (uses pre-computed zone_ids from server)
            boreholeMarkers.forEach((grabCircle) => {
                const markerGroup = grabCircle.markerGroup;
                let shouldBeVisible;
                
                if (mode === 'hide_zone_boreholes') {
                    // Mode: Hide borehole if it's INSIDE a hidden zone
                    const locationZoneIds = grabCircle.zoneIds || [];
                    shouldBeVisible = isBoreholeVisibleByLocationZone(locationZoneIds);
                } else {
                    // Mode: clip_coverage (default) - Show borehole if coverage TOUCHES any visible zone
                    const coverageZoneIds = grabCircle.coverageZoneIds || [];
                    shouldBeVisible = isBoreholeVisibleByZones(coverageZoneIds);
                }
                
                if (shouldBeVisible) {
                    if (!map.hasLayer(markerGroup)) {
                        boreholesLayer.addLayer(markerGroup);
                    }
                } else {
                    if (map.hasLayer(markerGroup)) {
                        markerGroup.remove();
                    }
                }
            });
            
            // 3b. Update borehole colors (SSOT: hidden zones = non-existent for color)
            // Boreholes in a hidden zone should turn orange (outside visible zones)
            boreholeMarkers.forEach((grabCircle) => {
                if (!grabCircle.markerGroup || !map.hasLayer(grabCircle.markerGroup)) return;
                const coords = boreholesData.features[grabCircle.boreholeIndex]?.geometry?.coordinates;
                if (!coords) return;
                updateMarkerForZoneChange(grabCircle, coords[0], coords[1]);
            });
            
            // 4. Fetch PROPOSED coverages from server (SSOT - server handles all filtering)
            const hiddenZones = getHiddenZoneNames();
            
            if (hiddenZones.length === 0) {
                // All zones visible - fetch full coverages
                const coverages = await fetchAllCoverages();
                renderCoverages(coverages);
            } else {
                // Some zones hidden - server filters based on mode
                const filteredCoverages = await fetchFilteredCoverages(hiddenZones, mode);
                renderCoverages(filteredCoverages);
            }
            
            // 5. Fetch EXISTING coverages from server (SSOT - server clips to visible zones)
            if (hiddenZones.length === 0) {
                // All zones visible - fetch full existing coverage
                const existingCoverage = await fetchExistingCoverage();
                renderExistingCoverage(existingCoverage);
            } else {
                // Some zones hidden - server clips existing coverage to visible zones
                const filteredExisting = await fetchFilteredExistingCoverage(hiddenZones);
                renderExistingCoverage(filteredExisting);
            }
            
            // 6. Re-sync coverage zones to markers after re-rendering
            syncCoverageZonesToMarkers();
            
            // 7. Update stat-row styling in coverage panel (grey out hidden zones)
            const statRow = document.querySelector(`.stat-row[data-zone="${zoneName}"]`);
            if (statRow) {
                statRow.classList.toggle('hidden-zone', !visible);
            }
            
            // 8. Update group header and total row styling
            updateCoverageStatsGreyout();
            
            // 9. Update count display
            updateBoreholeCountDisplay();
            
            const t_end = performance.now();
            console.log(`‚úÖ Zone toggle complete in ${(t_end - t_start).toFixed(1)}ms (mode: ${mode})`);
        }
        
        /**
         * Update grey-out styling for group headers and total row based on zone visibility.
         * Called after zone visibility changes to reflect partial-hidden state.
         */
        function updateCoverageStatsGreyout() {
            // Update each group header's partial-hidden class
            document.querySelectorAll('.zone-group').forEach(group => {
                const layerKey = group.dataset.layer;
                const childCbs = group.querySelectorAll('.zone-checkbox');
                const allVisible = Array.from(childCbs).every(cb => cb.checked);
                
                const header = group.querySelector('.group-header');
                if (header) {
                    header.classList.toggle('partial-hidden', !allVisible);
                }
            });
            
            // Update total row if any zones are hidden
            const anyHidden = Object.values(zoneVisibility).includes(false);
            const totalRow = document.querySelector('.total-row');
            if (totalRow) {
                totalRow.classList.toggle('partial-hidden', anyHidden);
            }
        }
        
        // DEPRECATED: This function was part of the old visibility system that used
        // runtime point-in-polygon tests. It's no longer needed because:
        // 1. Boreholes now have zone_ids pre-computed by the server
        // 2. toggleZoneVisibility() uses zone_ids for instant visibility
        // 3. Coverage visibility derives from parent borehole visibility
        //
        // Kept as no-op for backward compatibility with any existing calls
        async function updateBoreholeVisibilityForZones() {
            console.warn('‚ö†Ô∏è updateBoreholeVisibilityForZones() is deprecated. ' +
                         'Use toggleZoneVisibility() which uses zone_ids for instant updates.');
            // No-op - all visibility logic is now in toggleZoneVisibility()
        }
        
        // Simple point-in-polygon test for GeoJSON geometry
        function isPointInPolygon(point, geometry) {
            if (geometry.type === 'Polygon') {
                return pointInPolygonRing(point, geometry.coordinates[0]);
            } else if (geometry.type === 'MultiPolygon') {
                for (const polygon of geometry.coordinates) {
                    if (pointInPolygonRing(point, polygon[0])) {
                        return true;
                    }
                }
            }
            return false;
        }
        
        // Ray casting algorithm for point in polygon
        function pointInPolygonRing(point, ring) {
            const [x, y] = point;
            let inside = false;
            
            for (let i = 0, j = ring.length - 1; i < ring.length; j = i++) {
                const [xi, yi] = ring[i];
                const [xj, yj] = ring[j];
                
                if (((yi > y) !== (yj > y)) && (x < (xj - xi) * (y - yi) / (yj - yi) + xi)) {
                    inside = !inside;
                }
            }
            
            return inside;
        }
        
        async function updateDataTimestamp() {
            const dataInfo = await fetchDataInfo();
            if (!dataInfo) return;
            
            const container = document.getElementById('dataTimestamp');
            
            if (dataInfo.data_file_modified) {
                // Parse ISO date and format for display
                const modifiedDate = new Date(dataInfo.data_file_modified);
                const formattedDate = modifiedDate.toLocaleString('en-GB', {
                    day: '2-digit',
                    month: 'short',
                    year: 'numeric',
                    hour: '2-digit',
                    minute: '2-digit'
                });
                container.innerHTML = `üìÅ Data from: ${formattedDate}`;
            } else {
                container.innerHTML = '';
            }
            
            // Check for timestamp warning and show alert if files are out of sync
            if (dataInfo.timestamp_warning) {
                const warning = dataInfo.timestamp_warning;
                container.innerHTML += ` <span style="color: #e74c3c; cursor: pointer;" title="Click for details" onclick="showTimestampWarning()">‚ö†Ô∏è ${warning.diff_hours}h diff</span>`;
                
                // Store warning details globally for the popup
                window.timestampWarning = warning;
            }
            
            // Log source files to console for debugging
            if (dataInfo.source_files && dataInfo.source_files.length > 0) {
                console.log('üìÅ Source files:');
                dataInfo.source_files.forEach(f => {
                    console.log(`   ${f.type}: ${f.name} (${f.display})`);
                });
            }
        }
        
        function showTimestampWarning() {
            if (!window.timestampWarning) return;
            const w = window.timestampWarning;
            alert(`‚ö†Ô∏è Source File Timestamp Mismatch\n\n` +
                  `${w.message}\n\n` +
                  `Oldest: ${w.oldest.name}\n  (${w.oldest.display})\n\n` +
                  `Newest: ${w.newest.name}\n  (${w.newest.display})\n\n` +
                  `Recommendation: Re-run main.py to regenerate all files.`);
        }
        
        function renderZones(geojson) {
            zonesLayer.clearLayers();
            zonesLayer.addData(geojson);
            
            // Disable zone tooltips if configured (CONFIG should be loaded by now)
            if (CONFIG && CONFIG.ui && CONFIG.ui.show_zone_tooltips === false) {
                zonesLayer.eachLayer((layer) => {
                    if (layer.unbindTooltip) {
                        layer.unbindTooltip();
                    }
                });
                console.log('üîï Zone tooltips disabled via config');
            }
            
            // Update info panel
            document.getElementById('zoneCount').textContent = geojson.features.length;
        }
        
        function getBoreholeVisibleRadius() {
            return (CONFIG && CONFIG.boreholeMarker) ? CONFIG.boreholeMarker.visible_radius_m : 8;
        }
        
        function getBoreholeGrabRadius() {
            return (CONFIG && CONFIG.boreholeMarker) ? CONFIG.boreholeMarker.grab_radius_m : 24;
        }
        
        function getBoreholeColor() {
            return (CONFIG && CONFIG.boreholeMarker) ? CONFIG.boreholeMarker.color : '#000000';
        }
        
        function getOutsideZoneColor() {
            return (CONFIG && CONFIG.boreholeMarker) ? CONFIG.boreholeMarker.outside_zone_color : '#FF8C00';
        }
        
        function getOutsideZoneRadiusM() {
            // Outside-zone markers are 2x the size of inside-zone markers by default
            return (CONFIG && CONFIG.boreholeMarker) ? CONFIG.boreholeMarker.outside_zone_radius_m : 16;
        }
        
        // Check if a point is inside any VISIBLE zone (SSOT: hidden zones treated as non-existent)
        function isPointInAnyZone(lon, lat) {
            if (!zonesData || !zonesData.features) return false;
            
            const point = [lon, lat]; // [lon, lat] for GeoJSON
            for (const feature of zonesData.features) {
                const zoneName = feature.properties?.zone_name || feature.properties?.display_name;
                // Skip hidden zones - they don't exist for coverage/color purposes
                if (zoneName && zoneVisibility[zoneName] === false) continue;
                if (isPointInPolygon(point, feature.geometry)) {
                    return true;
                }
            }
            return false;
        }
        
        // Create visible marker based on zone membership
        // Both use L.circle (meters, scales with zoom) for consistency during drag operations
        // Inside zone: black marker at visible_radius_m
        // Outside zone: orange marker at outside_zone_radius_m (2x visible by default)
        function createVisibleMarker(latlng, isInsideZone) {
            if (isInsideZone) {
                const visibleRadius = getBoreholeVisibleRadius();
                const markerColor = getBoreholeColor();
                return L.circle(latlng, {
                    radius: visibleRadius,
                    color: markerColor,
                    fillColor: markerColor,
                    fillOpacity: 1,
                    weight: 0,
                    interactive: false
                });
            } else {
                const outsideColor = getOutsideZoneColor();
                const outsideRadius = getOutsideZoneRadiusM();  // 2x visible_radius by default
                return L.circle(latlng, {
                    radius: outsideRadius,
                    color: outsideColor,
                    fillColor: outsideColor,
                    fillOpacity: 1,
                    weight: 0,
                    interactive: false
                });
            }
        }
        
        // Update marker when moving between zones
        // Both use L.circle, so just update color and radius (no marker recreation)
        function updateMarkerForZoneChange(grabCircle, lon, lat) {
            const isInsideZone = isPointInAnyZone(lon, lat);
            const wasInsideZone = grabCircle.isInsideZone;
            
            // If zone membership changed, update the marker color and radius
            if (isInsideZone !== wasInsideZone) {
                const visibleCircle = grabCircle.visibleCircle;
                const newColor = isInsideZone ? getBoreholeColor() : getOutsideZoneColor();
                const newRadius = isInsideZone ? getBoreholeVisibleRadius() : getOutsideZoneRadiusM();
                
                visibleCircle.setStyle({
                    color: newColor,
                    fillColor: newColor
                });
                visibleCircle.setRadius(newRadius);
                
                grabCircle.isInsideZone = isInsideZone;
            }
        }
        
        function renderBoreholes(geojson) {
            boreholesLayer.clearLayers();
            boreholeMarkers = [];
            
            const grabRadius = getBoreholeGrabRadius();
            
            geojson.features.forEach((feature, index) => {
                const coords = feature.geometry.coordinates;
                const [lon, lat] = coords;
                const latlng = [lat, lon];
                
                const boreholeId = feature.properties.location_id || `PROP_${index}`;
                
                // Get zone_ids from server (single source of truth)
                const zoneIds = feature.properties.zone_ids || [];
                
                // Check if this borehole should be hidden based on zone visibility
                // Uses pre-computed zone_ids - instant, no geometry tests
                const shouldHide = !isBoreholeVisibleByZones(zoneIds);
                
                // Check zone membership for marker styling
                const isInsideZone = zoneIds.length > 0;
                
                // Create invisible grab circle (larger, for easier dragging)
                const grabCircle = L.circle(latlng, {
                    radius: grabRadius,
                    color: 'transparent',
                    fillColor: 'transparent',
                    fillOpacity: 0,
                    weight: 0,
                    interactive: true,
                    bubblingMouseEvents: false
                });
                
                // Create visible marker based on zone membership
                // Inside zone: L.circle (meters, scales with zoom) - black
                // Outside zone: L.circleMarker (pixels, fixed screen size) - orange
                const visibleCircle = createVisibleMarker(latlng, isInsideZone);
                
                // Group them together
                const markerGroup = L.layerGroup([grabCircle, visibleCircle]);
                
                // Store metadata on grab circle (which handles events)
                grabCircle.boreholeIndex = index;
                grabCircle.boreholeId = boreholeId;
                grabCircle.zoneIds = zoneIds;  // Pre-computed zone associations from server
                grabCircle.visibleCircle = visibleCircle;
                grabCircle.markerGroup = markerGroup;
                grabCircle.isInsideZone = isInsideZone;  // Track zone membership for transitions
                
                // Hover effects for better visual feedback
                const hoverScale = CONFIG?.boreholeMarker?.hover_scale || 2.0;  // From config or default
                let isDragging = false;  // Track drag state for hover effects
                
                grabCircle.on('mouseover', () => {
                    if (!isDragging) {
                        // Get current radius and scale it for hover
                        const currentRadius = grabCircle.visibleCircle.getRadius();
                        grabCircle.visibleCircle.setRadius(currentRadius * hoverScale);
                        map.getContainer().style.cursor = 'grab';
                    }
                });
                
                grabCircle.on('mouseout', () => {
                    if (!isDragging) {
                        // Restore normal radius based on marker type
                        if (grabCircle.isInsideZone) {
                            grabCircle.visibleCircle.setRadius(getBoreholeVisibleRadius());
                        } else {
                            grabCircle.visibleCircle.setRadius(getOutsideZoneRadiusM());
                        }
                        map.getContainer().style.cursor = '';
                    }
                });
                
                // Custom drag handling
                let dragStartLatLng = null;
                
                grabCircle.on('mousedown', (e) => {
                    if (e.originalEvent.shiftKey) return; // Don't start drag on shift+click
                    
                    isDragging = true;
                    dragStartLatLng = grabCircle.getLatLng();
                    
                    // Save state BEFORE dragging for undo
                    saveStateForUndo();
                    
                    // Disable map dragging
                    map.dragging.disable();
                    
                    // Change cursor
                    map.getContainer().style.cursor = 'grabbing';
                    
                    // Handle mouse move on map
                    map.on('mousemove', onDragMove);
                    map.on('mouseup', onDragEnd);
                });
                
                function onDragMove(e) {
                    if (!isDragging) return;
                    
                    const newLatLng = e.latlng;
                    grabCircle.setLatLng(newLatLng);
                    visibleCircle.setLatLng(newLatLng);
                }
                
                async function onDragEnd(e) {
                    if (!isDragging) return;
                    
                    const t_drag_end = performance.now();
                    console.log(`üñ±Ô∏è [DRAG] Drag ended`);
                    
                    isDragging = false;
                    map.dragging.enable();
                    map.getContainer().style.cursor = '';
                    
                    // Remove event listeners
                    map.off('mousemove', onDragMove);
                    map.off('mouseup', onDragEnd);
                    
                    const newLatLng = grabCircle.getLatLng();
                    
                    // Only update if position actually changed
                    if (newLatLng.lat !== dragStartLatLng.lat || newLatLng.lng !== dragStartLatLng.lng) {
                        const t_api_start = performance.now();
                        const result = await updateBoreholePosition(
                            grabCircle.boreholeIndex,
                            newLatLng.lng,
                            newLatLng.lat
                        );
                        const t_api_end = performance.now();
                        console.log(`    [DRAG] API call took: ${(t_api_end - t_api_start).toFixed(1)}ms`);
                        
                        if (result) {
                            const t_ui_start = performance.now();
                            
                            // Update local data
                            boreholesData.features[grabCircle.boreholeIndex].geometry.coordinates = [newLatLng.lng, newLatLng.lat];
                            
                            // Update zone_ids from server (for zone transition styling)
                            if (result.zone_ids) {
                                grabCircle.zoneIds = result.zone_ids;
                                boreholesData.features[grabCircle.boreholeIndex].properties.zone_ids = result.zone_ids;
                            }
                            
                            // Update coverage_zone_ids from coverage response (for visibility filtering)
                            if (result.coverage && result.coverage.properties && result.coverage.properties.zones) {
                                grabCircle.coverageZoneIds = result.coverage.properties.zones;
                            } else {
                                grabCircle.coverageZoneIds = [];  // No coverage = empty zones
                            }
                            
                            // Re-evaluate visibility based on new COVERAGE zone associations (R1)
                            const shouldBeVisible = isBoreholeVisibleByZones(grabCircle.coverageZoneIds);
                            if (!shouldBeVisible) {
                                // Borehole's coverage no longer touches any visible zone - hide it
                                grabCircle.markerGroup.remove();
                                // Also hide its coverage
                                coverageLayer.eachLayer((layer) => {
                                    if (layer.feature?.properties?.borehole_index === grabCircle.boreholeIndex) {
                                        layer.setStyle({ opacity: 0, fillOpacity: 0 });
                                    }
                                });
                                console.log(`üìç Borehole ${grabCircle.boreholeId} coverage no longer touches visible zones, now hidden`);
                            }
                            
                            // Update marker type if zone membership changed (L.circle <-> L.circleMarker)
                            updateMarkerForZoneChange(grabCircle, newLatLng.lng, newLatLng.lat);
                            
                            // Update single coverage polygon (handles null coverage for points outside zones)
                            updateSingleCoverage(grabCircle.boreholeIndex, result.coverage);
                            
                            // Update info panel
                            showBoreholeInfo(grabCircle, result.zone_info);
                            
                            // Update count display
                            updateBoreholeCountDisplay();
                            
                            const t_ui_end = performance.now();
                            console.log(`    [DRAG] UI update took: ${(t_ui_end - t_ui_start).toFixed(1)}ms`);
                            
                            // Lazy stats update - fetch after short delay for perceived instant response
                            if (result.stats_pending) {
                                setTimeout(() => refreshCoverageStats(), 50);
                            } else if (result.stats) {
                                renderCoverageStats(result.stats);
                            }
                            
                            const t_drag_total = performance.now();
                            console.log(`‚úÖ [DRAG] Total drag operation: ${(t_drag_total - t_drag_end).toFixed(1)}ms`);
                        }
                    }
                }
                
                // Shift+Click to delete
                grabCircle.on('click', async (e) => {
                    if (e.originalEvent.shiftKey) {
                        const t_delete_start = performance.now();
                        console.log(`üóëÔ∏è [DELETE-UI] Shift+click delete triggered for borehole ${grabCircle.boreholeIndex}`);
                        
                        // Save state for undo before deleting
                        saveStateForUndo();
                        
                        const deletedIndex = grabCircle.boreholeIndex;
                        const t_api_start = performance.now();
                        const result = await deleteBorehole(deletedIndex);
                        const t_api_end = performance.now();
                        console.log(`    [DELETE-UI] API call took: ${(t_api_end - t_api_start).toFixed(1)}ms`);
                        
                        if (result && result.success) {
                            const t_ui_start = performance.now();
                            
                            // Update local data
                            boreholesData = result.boreholes;
                            
                            // Re-render boreholes with new indices
                            renderBoreholes(boreholesData);
                            
                            // Remove deleted coverage and update indices (efficient - no API call)
                            removeCoverageByIndex(deletedIndex);
                            
                            // Re-apply zone visibility after re-rendering
                            updateBoreholeVisibilityForZones();
                            
                            const t_ui_end = performance.now();
                            console.log(`    [DELETE-UI] UI update took: ${(t_ui_end - t_ui_start).toFixed(1)}ms`);
                            
                            // Lazy stats update - fetch after a short delay for snappy UI
                            if (result.stats_pending) {
                                // Defer stats computation - UI feels instant, stats update shortly after
                                setTimeout(async () => {
                                    await refreshCoverageStats();
                                }, 50);  // 50ms delay - UI updates first, then stats
                            } else if (result.stats) {
                                renderCoverageStats(result.stats);
                            }
                            
                            const t_delete_total = performance.now();
                            console.log(`‚úÖ [DELETE-UI] Total delete operation: ${(t_delete_total - t_delete_start).toFixed(1)}ms`);
                        }
                    } else {
                        showBoreholeInfo(grabCircle, null);
                    }
                });
                
                // Only add to map if not in a hidden zone
                if (!shouldHide) {
                    markerGroup.addTo(boreholesLayer);
                }
                boreholeMarkers.push(grabCircle);  // Always store for reference (needed for visibility toggling)
            });
            
            // Update info panel
            document.getElementById('boreholeCount').textContent = geojson.features.length;
        }
        
        function renderCoverages(geojson) {
            coverageLayer.clearLayers();
            coverageLayer.addData(geojson);
        }
        
        function renderExistingCoverage(geojson) {
            existingCoverageLayer.clearLayers();
            if (geojson && geojson.features && geojson.features.length > 0) {
                existingCoverageLayer.addData(geojson);
                
                // Apply style from config (must be after addData since setStyle only affects existing features)
                if (CONFIG && CONFIG.existingCoverageStyle) {
                    const style = CONFIG.existingCoverageStyle;
                    existingCoverageLayer.setStyle({
                        color: style.color || '#27ae60',
                        weight: style.weight || 2,
                        opacity: style.opacity || 0.7,
                        fillColor: style.fill_color || '#2ecc71',
                        fillOpacity: style.fill_opacity || 0.35
                    });
                    console.log(`üé® Applied existing coverage style: fillColor=${style.fill_color}`);
                }
                
                console.log(`‚úÖ Rendered ${geojson.features.length} existing coverage polygons`);
            }
        }
        
        function updateSingleCoverage(boreholeIndex, coverage) {
            // Remove ALL coverages for this borehole (handle potential duplicates)
            const toRemove = [];
            coverageLayer.eachLayer(layer => {
                const props = layer.feature?.properties;
                if (props && props.borehole_index === boreholeIndex) {
                    toRemove.push(layer);
                }
            });
            toRemove.forEach(layer => coverageLayer.removeLayer(layer));
            
            // Add new coverage if valid
            if (coverage && coverage.geometry) {
                coverage.properties = coverage.properties || {};
                coverage.properties.borehole_index = boreholeIndex;
                coverageLayer.addData(coverage);
            }
        }
        
        // Remove coverage by borehole index and reindex remaining coverages
        // Used for delete operation (avoids re-fetching all coverages from server)
        function removeCoverageByIndex(deletedIndex) {
            const toRemove = [];
            const toUpdate = [];
            
            // Find coverage to remove and coverages that need index update
            coverageLayer.eachLayer(layer => {
                const props = layer.feature?.properties;
                if (props && typeof props.borehole_index === 'number') {
                    if (props.borehole_index === deletedIndex) {
                        toRemove.push(layer);
                    } else if (props.borehole_index > deletedIndex) {
                        // This borehole's index will shift down by 1
                        toUpdate.push(layer);
                    }
                }
            });
            
            // Remove deleted borehole's coverage
            toRemove.forEach(layer => coverageLayer.removeLayer(layer));
            
            // Update indices for remaining boreholes (shift down)
            toUpdate.forEach(layer => {
                layer.feature.properties.borehole_index -= 1;
            });
        }
        
        function showBoreholeInfo(marker, zoneInfo) {
            const panel = document.getElementById('selectedBorehole');
            panel.style.display = 'block';
            
            document.getElementById('selectedId').textContent = marker.boreholeId;
            
            if (zoneInfo) {
                const zones = Object.keys(zoneInfo);
                document.getElementById('selectedZone').textContent = zones.join(', ') || 'Outside zones';
                
                const radii = Object.values(zoneInfo);
                document.getElementById('selectedRadius').textContent = 
                    radii.length > 0 ? radii.map(r => `${r}m`).join(', ') : '-';
            } else {
                document.getElementById('selectedZone').textContent = '-';
                document.getElementById('selectedRadius').textContent = '-';
            }
        }
        
        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        // üöÄ INITIALIZATION
        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        
        function applyConfig() {
            // Apply configuration to layer styles and variables
            if (!CONFIG) return;
            
            // Update zone colors from config
            if (CONFIG.zoneColors) {
                zoneColors = CONFIG.zoneColors;
            }
            
            // Update base layer opacity
            if (CONFIG.map && CONFIG.map.base_layer_opacity !== undefined) {
                baseLayer.setOpacity(CONFIG.map.base_layer_opacity);
            }
            
            // Update zone polygon style from config
            if (CONFIG.zonePolygonStyle) {
                const style = CONFIG.zonePolygonStyle;
                zonesLayer.setStyle({
                    color: style.color || '#666666',
                    weight: style.weight || 3,
                    opacity: style.opacity || 0.8,
                    fillColor: style.fill_color || '#ffffff',
                    fillOpacity: style.fill_opacity || 1.0
                });
            }
            
            // Update existing coverage style from config
            if (CONFIG.existingCoverageStyle) {
                const style = CONFIG.existingCoverageStyle;
                existingCoverageLayer.setStyle({
                    color: style.color || '#27ae60',
                    weight: style.weight || 2,
                    opacity: style.opacity || 0.7,
                    fillColor: style.fill_color || '#2ecc71',
                    fillOpacity: style.fill_opacity || 0.35
                });
            }
            
            // Apply coverage panel width from config
            if (CONFIG.ui && CONFIG.ui.coverage_panel_width_px) {
                document.documentElement.style.setProperty(
                    '--coverage-panel-width', 
                    CONFIG.ui.coverage_panel_width_px + 'px'
                );
            }
            
            // Apply progress bar width from config
            if (CONFIG.ui && CONFIG.ui.coverage_progress_bar_width_px) {
                document.documentElement.style.setProperty(
                    '--coverage-progress-bar-width', 
                    CONFIG.ui.coverage_progress_bar_width_px + 'px'
                );
            }
            
            // Note: Zone tooltips are handled in renderZones() after zones are loaded
            
            // Apply zone focus outline setting (disable black rectangle on click)
            if (CONFIG.ui && CONFIG.ui.show_zone_focus_outline === false) {
                // Inject CSS to disable focus outline
                const styleEl = document.createElement('style');
                styleEl.id = 'zone-focus-outline-style';
                styleEl.textContent = '.leaflet-interactive:focus { outline: none; }';
                document.head.appendChild(styleEl);
                console.log('üîï Zone focus outline disabled via config');
            } else {
                // Remove the style if it was previously added
                const existingStyle = document.getElementById('zone-focus-outline-style');
                if (existingStyle) {
                    existingStyle.remove();
                }
            }
            
            console.log('üìã Config applied:', CONFIG);
        }
        
        async function initialize() {
            const loadingOverlay = document.getElementById('loadingOverlay');
            
            try {
                // Load config first
                CONFIG = await fetchConfig();
                if (CONFIG) {
                    applyConfig();
                }
                
                // Load zones
                zonesData = await fetchZones();
                renderZones(zonesData);
                
                // Load existing coverage (green, from main.py output)
                const existingCoverage = await fetchExistingCoverage();
                renderExistingCoverage(existingCoverage);
                
                // Load boreholes
                boreholesData = await fetchBoreholes();
                originalBoreholesData = JSON.parse(JSON.stringify(boreholesData));  // Save initial state for reset
                renderBoreholes(boreholesData);
                
                // Load initial coverages (blue, proposed) - includes stats for efficiency
                const coveragesResponse = await fetchAllCoverages();
                renderCoverages(coveragesResponse);
                
                // Sync coverage zones to markers (for visibility filtering)
                syncCoverageZonesToMarkers();
                
                // Render coverage stats from the same response (avoids extra API call)
                if (coveragesResponse.stats) {
                    renderCoverageStats(coveragesResponse.stats);
                } else {
                    // Fallback for backward compatibility
                    await refreshCoverageStats();
                }
                
                // Load data timestamp
                await updateDataTimestamp();
                
                // Fit map to zones bounds
                if (zonesLayer.getBounds().isValid()) {
                    map.fitBounds(zonesLayer.getBounds(), { padding: [20, 20] });
                }
                
                console.log('‚úÖ Initialization complete');
                
            } catch (error) {
                console.error('‚ùå Initialization failed:', error);
                alert('Failed to load data. Check console for details.');
            } finally {
                loadingOverlay.style.display = 'none';
            }
        }
        
        // Start initialization
        initialize();
        
        // Toggle base map visibility
        document.getElementById('toggleBaseMap').addEventListener('change', function() {
            if (this.checked) {
                baseLayer.setOpacity(0.25);
            } else {
                baseLayer.setOpacity(0);
            }
        });
        
        // Toggle left panel (Coverage by Zone)
        document.getElementById('leftPanelToggle').addEventListener('click', function() {
            const panel = document.getElementById('leftPanel');
            const toggleBtn = this;
            
            panel.classList.toggle('collapsed');
            toggleBtn.classList.toggle('panel-open');
        });
        
        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        // üîò BUTTON HANDLERS
        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        
        // Undo button
        document.getElementById('undoBtn').addEventListener('click', performUndo);
        
        // Reset button
        document.getElementById('resetBtn').addEventListener('click', performReset);
        
        // Export CSV button - exports only visible boreholes (respects all filters)
        document.getElementById('exportCsvBtn').addEventListener('click', function() {
            // Use generic helper to get hidden boreholes (works with any current/future filter)
            const hiddenIndices = getHiddenBoreholeIndices();
            
            let exportUrl = '/api/boreholes/export';
            if (hiddenIndices.length > 0) {
                const excludeParam = hiddenIndices.join(',');
                exportUrl += `?excludeIndices=${excludeParam}`;
            }
            window.location.href = exportUrl;
        });
        
        // Delete outside boreholes button - server identifies outside via zone_ids (SSOT)
        document.getElementById('deleteOutsideBtn').addEventListener('click', async function() {
            // Count outside boreholes for confirmation (read from server-provided zone_ids)
            const outsideCount = boreholeMarkers.filter(
                gc => !gc.zoneIds || gc.zoneIds.length === 0
            ).length;
            
            if (outsideCount === 0) {
                alert('No outside-zone boreholes to delete.');
                return;
            }
            
            if (!confirm(`Delete ${outsideCount} outside-zone (orange) borehole${outsideCount > 1 ? 's' : ''}?`)) {
                return;
            }
            
            // Save state for undo before bulk delete
            saveStateForUndo();
            
            try {
                const response = await fetch('/api/boreholes/delete-outside', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' }
                });
                const result = await response.json();
                
                if (result.success) {
                    // Invalidate all coverages (bulk operation)
                    coverageLayer.clearLayers();
                    
                    // Update local data from server response
                    boreholesData = result.boreholes;
                    renderBoreholes(boreholesData);
                    
                    // Re-fetch all coverages for remaining boreholes
                    const coveragesResponse = await fetchAllCoverages();
                    renderCoverages(coveragesResponse);
                    
                    // Sync coverage zones to markers
                    syncCoverageZonesToMarkers();
                    
                    // Re-apply zone visibility
                    updateBoreholeVisibilityForZones();
                    
                    // Update count
                    updateBoreholeCountDisplay();
                    
                    // Lazy stats update
                    if (result.stats_pending) {
                        setTimeout(() => refreshCoverageStats(), 50);
                    }
                    
                    console.log(`üóëÔ∏è Deleted ${result.deleted_count} outside-zone boreholes`);
                }
            } catch (error) {
                console.error('Failed to delete outside boreholes:', error);
            }
        });
        
        // Add borehole button
        document.getElementById('addBoreholeBtn').addEventListener('click', function() {
            addBoreholeMode = !addBoreholeMode;
            
            const btn = this;
            const indicator = document.getElementById('addModeIndicator');
            
            if (addBoreholeMode) {
                btn.classList.add('active');
                btn.textContent = '‚úï Cancel';
                indicator.style.display = 'block';
                map.getContainer().style.cursor = 'crosshair';
            } else {
                btn.classList.remove('active');
                btn.textContent = '+ Add Borehole';
                indicator.style.display = 'none';
                map.getContainer().style.cursor = '';
            }
        });
        
        // ESC key to cancel add mode
        document.addEventListener('keydown', function(e) {
            if (e.key === 'Escape' && addBoreholeMode) {
                document.getElementById('addBoreholeBtn').click();
            }
        });
        
        // Map click handler for adding boreholes
        map.on('click', async function(e) {
            if (!addBoreholeMode) return;
            
            const lat = e.latlng.lat;
            const lon = e.latlng.lng;
            
            // Save state for undo
            saveStateForUndo();
            
            // Add the borehole
            const result = await addNewBorehole(lon, lat);
            
            if (result && result.success) {
                // Update local data
                boreholesData = result.boreholes;
                
                // Re-render all boreholes (handles zone visibility via shouldHide)
                try {
                    renderBoreholes(boreholesData);
                } catch (err) {
                    console.error('‚ùå renderBoreholes failed after add:', err);
                }
                
                // Add the new coverage
                if (result.coverage) {
                    result.coverage.properties = result.coverage.properties || {};
                    result.coverage.properties.borehole_index = result.index;
                    coverageLayer.addData(result.coverage);
                }
                
                // Re-apply zone visibility to all boreholes (replaces deprecated no-op)
                const hiddenZones = getHiddenZoneNames();
                if (hiddenZones.length > 0) {
                    boreholeMarkers.forEach((gc) => {
                        const zoneIds = gc.zoneIds || [];
                        const coverageZoneIds = gc.coverageZoneIds || [];
                        const mode = getZoneVisibilityMode();
                        let shouldBeVisible;
                        if (mode === 'hide_zone_boreholes') {
                            shouldBeVisible = isBoreholeVisibleByLocationZone(zoneIds);
                        } else {
                            shouldBeVisible = isBoreholeVisibleByZones(coverageZoneIds.length > 0 ? coverageZoneIds : zoneIds);
                        }
                        if (shouldBeVisible) {
                            if (!map.hasLayer(gc.markerGroup)) boreholesLayer.addLayer(gc.markerGroup);
                        } else {
                            if (map.hasLayer(gc.markerGroup)) gc.markerGroup.remove();
                        }
                    });
                }
                
                // Render coverage stats from response (fast - avoids extra API call)
                if (result.stats) {
                    renderCoverageStats(result.stats);
                }
                
                // Update count display after visibility filtering
                updateBoreholeCountDisplay();
                
                console.log(`‚ûï Added borehole at (${lon.toFixed(6)}, ${lat.toFixed(6)})`);
            }
            
            // Exit add mode after adding
            document.getElementById('addBoreholeBtn').click();
        });
    </script>
</body>
</html>
