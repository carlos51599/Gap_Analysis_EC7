<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Zone Coverage Visualization</title>
    
    <!-- Leaflet CSS -->
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
    
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
        }
        
        #map {
            width: 100%;
            height: 100vh;
            background: #f5f5f5;
        }
        
        .info-panel {
            position: absolute;
            top: 10px;
            right: 10px;
            z-index: 1000;
            background: white;
            padding: 15px;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.2);
            max-width: 300px;
            font-size: 14px;
        }
        
        .info-panel h3 {
            margin-bottom: 10px;
            color: #333;
        }
        
        .info-panel .stat {
            display: flex;
            justify-content: space-between;
            margin-bottom: 5px;
        }
        
        .info-panel .stat-label {
            color: #666;
        }
        
        .info-panel .stat-value {
            font-weight: bold;
            color: #333;
        }
        
        .info-panel .divider {
            border-top: 1px solid #eee;
            margin: 10px 0;
        }
        
        .zone-legend {
            margin-top: 10px;
        }
        
        .zone-legend-item {
            display: flex;
            align-items: center;
            margin-bottom: 5px;
        }
        
        .zone-legend-color {
            width: 16px;
            height: 16px;
            margin-right: 8px;
            border-radius: 3px;
        }
        
        .loading-overlay {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(255,255,255,0.9);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 2000;
        }
        
        .loading-spinner {
            text-align: center;
        }
        
        .loading-spinner .spinner {
            width: 40px;
            height: 40px;
            border: 4px solid #f3f3f3;
            border-top: 4px solid #3498db;
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin: 0 auto 10px;
        }
        
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        
        .toggle-row {
            margin: 5px 0;
        }
        
        .toggle-label {
            display: flex;
            align-items: center;
            cursor: pointer;
            font-size: 13px;
        }
        
        .toggle-label input {
            margin-right: 8px;
            cursor: pointer;
        }
        
        .action-buttons {
            margin-top: 10px;
            display: flex;
            gap: 8px;
            flex-wrap: wrap;
        }
        
        .action-btn {
            padding: 8px 12px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 12px;
            font-weight: 500;
            transition: background 0.2s, opacity 0.2s;
        }
        
        .action-btn:hover {
            opacity: 0.9;
        }
        
        .action-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }
        
        .btn-undo {
            background: #95a5a6;
            color: white;
        }
        
        .btn-add {
            background: #27ae60;
            color: white;
        }
        
        .btn-add.active {
            background: #e74c3c;
        }
        
        .btn-reset {
            background: #3498db;
            color: white;
        }
        
        .btn-export {
            background: #9b59b6;
            color: white;
            width: 100%;
        }
        
        .add-mode-indicator {
            position: absolute;
            top: 50px;
            left: 50%;
            transform: translateX(-50%);
            background: #27ae60;
            color: white;
            padding: 10px 20px;
            border-radius: 20px;
            font-size: 14px;
            font-weight: bold;
            z-index: 1000;
            box-shadow: 0 2px 10px rgba(0,0,0,0.3);
            display: none;
        }
        
        .help-text {
            font-size: 11px;
            color: #888;
            margin-top: 8px;
            line-height: 1.4;
        }
        
        .delete-hint {
            display: block;
            width: 100%;
            background: #e74c3c;
            color: white;
            padding: 6px 12px;
            border-radius: 20px;
            font-size: 11px;
            font-weight: 500;
            text-align: center;
            box-sizing: border-box;
        }
        
        .coverage-stats {
            margin-top: 10px;
            padding: 10px;
            background: white;
            border-radius: 6px;
        }
        
        .coverage-stats h4 {
            margin: 0 0 8px 0;
            font-size: 12px;
            color: #333;
        }
        
        .coverage-stats .stat-row {
            display: flex;
            align-items: center;
            margin-bottom: 6px;
            font-size: 13px;
            gap: 8px;
        }
        
        .coverage-stats .zone-checkbox {
            width: 14px;
            height: 14px;
            cursor: pointer;
            flex-shrink: 0;
        }
        
        .coverage-stats .zone-name {
            color: #333;
            flex: 1;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }
        
        .coverage-stats .pct-value {
            font-weight: bold;
            min-width: 45px;
            text-align: right;
            flex-shrink: 0;
        }
        
        .coverage-stats .pct-good { color: #27ae60; }
        .coverage-stats .pct-medium { color: #f39c12; }
        .coverage-stats .pct-poor { color: #e74c3c; }
        
        .coverage-stats .progress-bar {
            width: var(--coverage-progress-bar-width, 100px);
            flex-shrink: 0;
            height: 6px;
            background: #e0e0e0;
            border-radius: 3px;
            margin: 0 8px;
            overflow: hidden;
        }
        
        .coverage-stats .progress-fill {
            height: 100%;
            border-radius: 3px;
            transition: width 0.3s ease;
        }
        
        .coverage-stats .total-row {
            border-top: 1px solid #ddd;
            padding-top: 8px;
            margin-top: 8px;
            font-weight: bold;
        }
        
        .coverage-stats .total-row .progress-bar {
            flex: 1;
            width: auto;
        }
        
        .data-timestamp {
            font-size: 10px;
            color: #888;
            margin-top: 8px;
            padding-top: 6px;
            border-top: 1px solid #eee;
        }
        
        /* ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
           LEFT PANEL - Coverage by Zone (collapsible)
           ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê */
        
        .left-panel {
            position: absolute;
            top: 10px;
            left: 10px;
            z-index: 1000;
            background: white;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.2);
            width: var(--coverage-panel-width, 320px);
            font-size: 14px;
            transition: transform 0.3s ease, opacity 0.3s ease;
        }
        
        .left-panel.collapsed {
            transform: translateX(-100%);
            opacity: 0;
            pointer-events: none;
        }
        
        .left-panel-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 12px 15px;
            border-bottom: 1px solid #eee;
            background: white;
            border-radius: 8px 8px 0 0;
        }
        
        .left-panel-header h4 {
            margin: 0;
            font-size: 14px;
            color: #333;
        }
        
        .left-panel-content {
            padding: 15px;
            max-height: calc(100vh - 150px);
            overflow-y: auto;
        }
        
        .panel-toggle-btn {
            position: absolute;
            top: 10px;
            left: 10px;
            z-index: 1001;
            width: 32px;
            height: 32px;
            background: white;
            border: none;
            border-radius: 6px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.2);
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 14px;
            transition: transform 0.3s ease, left 0.3s ease;
        }
        
        .panel-toggle-btn:hover {
            background: #f5f5f5;
        }
        
        .panel-toggle-btn.panel-open {
            left: calc(var(--coverage-panel-width, 320px) + 15px);  /* Position next to expanded panel */
        }
        
        .panel-toggle-btn .arrow {
            transition: transform 0.3s ease;
        }
        
        .panel-toggle-btn.panel-open .arrow {
            transform: rotate(180deg);
        }
    </style>
</head>
<body>
    <div id="map"></div>
    
    <!-- Left Panel Toggle Button -->
    <button class="panel-toggle-btn panel-open" id="leftPanelToggle" title="Toggle Coverage Panel">
        <span class="arrow">‚ñ∂</span>
    </button>
    
    <!-- Left Panel - Coverage by Zone -->
    <div class="left-panel" id="leftPanel">
        <div class="left-panel-header">
            <h4>Coverage by Zone</h4>
        </div>
        <div class="left-panel-content coverage-stats">
            <div id="coverageStatsContent">
                <span style="color: #888; font-size: 11px;">Loading...</span>
            </div>
            <div class="data-timestamp" id="dataTimestamp"></div>
        </div>
    </div>
    
    <div class="add-mode-indicator" id="addModeIndicator">
        üìç Click on map to add borehole (ESC to cancel)
    </div>
    
    <div class="info-panel" id="infoPanel">
        <h3>Overview</h3>
        <div class="stat">
            <span class="stat-label">Boreholes:</span>
            <span class="stat-value" id="boreholeCount">-</span>
        </div>
        <div class="stat">
            <span class="stat-label">Zones:</span>
            <span class="stat-value" id="zoneCount">-</span>
        </div>
        <div class="divider"></div>
        <div class="action-buttons">
            <button class="action-btn btn-undo" id="undoBtn" disabled title="Undo last action">
                ‚Ü© Undo
            </button>
            <button class="action-btn btn-add" id="addBoreholeBtn" title="Add new borehole">
                + Add Borehole
            </button>
            <button class="action-btn btn-reset" id="resetBtn" title="Reset to original positions">
                ‚ü≤ Reset
            </button>
        </div>
        <div class="help-text">
            <span class="delete-hint">Shift+Click on borehole to delete</span>
        </div>
        <div class="divider"></div>
        <div class="toggle-row">
            <label class="toggle-label">
                <input type="checkbox" id="toggleBaseMap" checked>
                <span>Show Background Map</span>
            </label>
        </div>
        <div class="divider"></div>
        <div id="selectedBorehole" style="display: none;">
            <h4 style="margin-bottom: 5px;">Selected Borehole</h4>
            <div class="stat">
                <span class="stat-label">ID:</span>
                <span class="stat-value" id="selectedId">-</span>
            </div>
            <div class="stat">
                <span class="stat-label">Zone:</span>
                <span class="stat-value" id="selectedZone">-</span>
            </div>
            <div class="stat">
                <span class="stat-label">Radius:</span>
                <span class="stat-value" id="selectedRadius">-</span>
            </div>
        </div>
        <div class="divider"></div>
        <div class="action-buttons">
            <button class="action-btn btn-export" id="exportCsvBtn" title="Export borehole coordinates to CSV">
                üì• Export CSV
            </button>
        </div>
    </div>
    
    <div class="loading-overlay" id="loadingOverlay">
        <div class="loading-spinner">
            <div class="spinner"></div>
            <div>Loading data...</div>
        </div>
    </div>
    
    <!-- Leaflet JS -->
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
    
    <script>
        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        // ÔøΩ CONFIGURATION (loaded from server)
        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        
        let CONFIG = null;  // Loaded from /api/config at startup
        
        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        // üó∫Ô∏è MAP INITIALIZATION
        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        
        // Initialize map (centered on UK) - will be re-centered after data loads
        const map = L.map('map', { zoomControl: false }).setView([51.5, -1.0], 14);
        
        // Add base layer (OpenStreetMap) with very reduced opacity
        const baseLayer = L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
            attribution: '&copy; OpenStreetMap contributors',
            opacity: 0.25
        }).addTo(map);
        
        // Layer groups - initialized with default styles, updated after config loads
        let zonesLayer = L.geoJSON(null, {
            style: {
                color: '#666666',
                weight: 3,
                opacity: 0.8,
                fillColor: '#ffffff',
                fillOpacity: 1
            },
            interactive: true,  // Enable interaction for tooltips
            onEachFeature: (feature, layer) => {
                const props = feature.properties || {};
                const zoneName = props.zone_name || props.display_name || 'Zone';
                // Bind tooltip that follows cursor along the geometry
                layer.bindTooltip(zoneName, {
                    permanent: false,
                    sticky: true,  // Follow the cursor
                    className: 'zone-tooltip'
                });
                // Prevent click from showing bounding box - instead highlight actual geometry
                layer.on('click', (e) => {
                    L.DomEvent.stopPropagation(e);  // Don't propagate to map
                });
            }
        });
        
        // Existing borehole coverage (green, below proposed)
        // Note: Style will be updated from CONFIG after data is loaded in renderExistingCoverage()
        const existingCoverageLayer = L.geoJSON(null, {
            style: {
                color: '#27ae60',
                weight: 2,
                opacity: 0.8,
                fillColor: '#5feb5f',  // Matches ec7_coverage.html: rgba(95, 235, 95, 0.85)
                fillOpacity: 0.85
            },
            interactive: false  // Let mouse events pass through to boreholes
        });
        
        const coverageLayer = L.geoJSON(null, {
            style: {
                color: '#2980b9',
                weight: 3,
                opacity: 0.8,
                fillColor: '#3498db',
                fillOpacity: 0.25
            },
            interactive: false  // Let mouse events pass through to boreholes
        });
        
        const boreholesLayer = L.layerGroup();
        
        // Add layers to map in order (zones at bottom, existing coverage, proposed coverage, boreholes on top)
        zonesLayer.addTo(map);
        existingCoverageLayer.addTo(map);
        coverageLayer.addTo(map);
        boreholesLayer.addTo(map);

        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        // üìä DATA STORAGE
        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        
        let boreholeMarkers = [];
        let zonesData = null;
        let boreholesData = null;
        let originalBoreholesData = null;  // Store initial state for reset
        
        // Zone visibility state: { "zone_name": true/false }
        let zoneVisibility = {};
        
        // Undo history stack
        let undoHistory = [];
        const MAX_UNDO_HISTORY = 50;
        
        // Add borehole mode
        let addBoreholeMode = false;
        
        // Zone colors
        // Zone colors - loaded from config, fallback here
        let zoneColors = {
            'Embankment': '#e74c3c',
            'Highways': '#3498db'
        };
        
        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        // üîÑ API FUNCTIONS
        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        
        async function fetchConfig() {
            try {
                const response = await fetch('/api/config');
                const data = await response.json();
                return data;
            } catch (error) {
                console.error('Failed to fetch config:', error);
                return null;
            }
        }
        
        async function fetchDataInfo() {
            try {
                const response = await fetch('/api/data/info');
                const data = await response.json();
                return data;
            } catch (error) {
                console.error('Failed to fetch data info:', error);
                return null;
            }
        }
        
        async function fetchZones() {
            try {
                const response = await fetch('/api/zones');
                const data = await response.json();
                return data;
            } catch (error) {
                console.error('Failed to fetch zones:', error);
                return { type: 'FeatureCollection', features: [] };
            }
        }
        
        async function fetchBoreholes() {
            try {
                const response = await fetch('/api/boreholes');
                const data = await response.json();
                return data;
            } catch (error) {
                console.error('Failed to fetch boreholes:', error);
                return { type: 'FeatureCollection', features: [] };
            }
        }
        
        async function fetchAllCoverages() {
            try {
                const response = await fetch('/api/coverage/all');
                const data = await response.json();
                return data;
            } catch (error) {
                console.error('Failed to fetch coverages:', error);
                return { type: 'FeatureCollection', features: [] };
            }
        }
        
        async function fetchExistingCoverage() {
            try {
                const response = await fetch('/api/existing-coverage');
                const data = await response.json();
                return data;
            } catch (error) {
                console.error('Failed to fetch existing coverage:', error);
                return { type: 'FeatureCollection', features: [] };
            }
        }
        
        async function fetchCoverageStats() {
            try {
                const response = await fetch('/api/coverage/stats');
                const data = await response.json();
                return data;
            } catch (error) {
                console.error('Failed to fetch coverage stats:', error);
                return null;
            }
        }
        
        async function updateBoreholePosition(index, lon, lat) {
            try {
                const response = await fetch('/api/coverage/update', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ index, lon, lat })
                });
                const data = await response.json();
                return data;
            } catch (error) {
                console.error('Failed to update borehole:', error);
                return null;
            }
        }
        
        async function deleteBorehole(index) {
            try {
                const response = await fetch('/api/borehole/delete', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ index })
                });
                const data = await response.json();
                return data;
            } catch (error) {
                console.error('Failed to delete borehole:', error);
                return null;
            }
        }
        
        async function restoreBoreholes(boreholesGeojson) {
            try {
                const response = await fetch('/api/borehole/restore', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ boreholes: boreholesGeojson })
                });
                const data = await response.json();
                return data;
            } catch (error) {
                console.error('Failed to restore boreholes:', error);
                return null;
            }
        }
        
        async function addNewBorehole(lon, lat, locationId = null) {
            try {
                const body = { lon, lat };
                if (locationId) body.location_id = locationId;
                
                const response = await fetch('/api/borehole/add', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(body)
                });
                const data = await response.json();
                return data;
            } catch (error) {
                console.error('Failed to add borehole:', error);
                return null;
            }
        }
        
        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        // üîÑ UNDO SYSTEM
        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        
        function saveStateForUndo() {
            // Deep clone current boreholes data
            const snapshot = JSON.parse(JSON.stringify(boreholesData));
            undoHistory.push(snapshot);
            
            // Limit history size
            if (undoHistory.length > MAX_UNDO_HISTORY) {
                undoHistory.shift();
            }
            
            updateUndoButton();
        }
        
        function updateUndoButton() {
            const undoBtn = document.getElementById('undoBtn');
            undoBtn.disabled = undoHistory.length === 0;
        }
        
        async function performUndo() {
            if (undoHistory.length === 0) return;
            
            const previousState = undoHistory.pop();
            boreholesData = previousState;
            
            // Sync restored state to server
            await restoreBoreholes(boreholesData);
            
            // Re-render boreholes
            renderBoreholes(boreholesData);
            
            // Re-compute coverages (now server has correct state)
            const coverages = await fetchAllCoverages();
            renderCoverages(coverages);
            
            // Re-apply zone visibility after re-rendering
            updateBoreholeVisibilityForZones();
            
            updateUndoButton();
            console.log('‚Ü©Ô∏è Undo performed');
            
            // Refresh coverage stats
            await refreshCoverageStats();
        }
        
        async function performReset() {
            if (!originalBoreholesData) return;
            
            // Restore to original state
            boreholesData = JSON.parse(JSON.stringify(originalBoreholesData));
            
            // Sync restored state to server
            await restoreBoreholes(boreholesData);
            
            // Re-render boreholes
            renderBoreholes(boreholesData);
            
            // Re-compute coverages
            const coverages = await fetchAllCoverages();
            renderCoverages(coverages);
            
            // Re-apply zone visibility after re-rendering
            updateBoreholeVisibilityForZones();
            
            // Clear undo history
            undoHistory = [];
            updateUndoButton();
            console.log('üîÑ Reset to original state');
            
            // Refresh coverage stats
            await refreshCoverageStats();
        }
        
        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        // üé® RENDERING FUNCTIONS
        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        
        function getCoverageStatsConfig() {
            return (CONFIG && CONFIG.coverageStats) ? CONFIG.coverageStats : {
                good_threshold: 90,
                medium_threshold: 50,
                good_color: '#27ae60',
                medium_color: '#f39c12',
                poor_color: '#e74c3c'
            };
        }
        
        function getPctClass(pct) {
            const cfg = getCoverageStatsConfig();
            if (pct >= cfg.good_threshold) return 'pct-good';
            if (pct >= cfg.medium_threshold) return 'pct-medium';
            return 'pct-poor';
        }
        
        function getPctColor(pct) {
            const cfg = getCoverageStatsConfig();
            if (pct >= cfg.good_threshold) return cfg.good_color;
            if (pct >= cfg.medium_threshold) return cfg.medium_color;
            return cfg.poor_color;
        }
        
        async function refreshCoverageStats() {
            const stats = await fetchCoverageStats();
            if (!stats) return;
            
            const container = document.getElementById('coverageStatsContent');
            
            // Initialize zone visibility for any new zones (default to visible)
            for (const zone of stats.per_zone) {
                if (zoneVisibility[zone.zone_name] === undefined) {
                    zoneVisibility[zone.zone_name] = true;
                }
            }
            
            // Build HTML for per-zone stats
            let html = '';
            
            for (const zone of stats.per_zone) {
                const pctClass = getPctClass(zone.coverage_pct);
                const pctColor = getPctColor(zone.coverage_pct);
                const isVisible = zoneVisibility[zone.zone_name] !== false;
                
                html += `
                    <div class="stat-row">
                        <input type="checkbox" class="zone-checkbox" 
                               data-zone="${zone.zone_name}" 
                               ${isVisible ? 'checked' : ''}
                               onchange="toggleZoneVisibility('${zone.zone_name}', this.checked)">
                        <span class="zone-name" title="${zone.zone_name}">${zone.zone_name}</span>
                        <div class="progress-bar">
                            <div class="progress-fill" style="width: ${Math.min(zone.coverage_pct, 100)}%; background: ${pctColor};"></div>
                        </div>
                        <span class="pct-value ${pctClass}">${zone.coverage_pct}%</span>
                    </div>
                `;
            }
            
            // Add total row (no checkbox for total)
            const totalPctClass = getPctClass(stats.total.coverage_pct);
            html += `
                <div class="stat-row total-row">
                    <span class="zone-name" style="margin-left: 22px;">Total</span>
                    <div class="progress-bar">
                        <div class="progress-fill" style="width: ${Math.min(stats.total.coverage_pct, 100)}%; background: ${getPctColor(stats.total.coverage_pct)};"></div>
                    </div>
                    <span class="pct-value ${totalPctClass}">${stats.total.coverage_pct}%</span>
                </div>
            `;
            
            container.innerHTML = html;
        }
        
        // Toggle zone visibility (zone polygon and boreholes inside it)
        function toggleZoneVisibility(zoneName, visible) {
            zoneVisibility[zoneName] = visible;
            
            // Update zone layer visibility
            zonesLayer.eachLayer((layer) => {
                const props = layer.feature?.properties;
                if (props && (props.zone_name === zoneName || props.display_name === zoneName)) {
                    if (visible) {
                        layer.setStyle({ opacity: 0.8, fillOpacity: 1 });
                    } else {
                        layer.setStyle({ opacity: 0, fillOpacity: 0 });
                    }
                }
            });
            
            // Update borehole and coverage visibility based on zone containment
            updateBoreholeVisibilityForZones();
        }
        
        // Update borehole visibility based on zone visibility settings
        function updateBoreholeVisibilityForZones() {
            if (!zonesData || !boreholesData) return;
            
            // Track which boreholes are hidden (by index)
            const hiddenBoreholeIndices = new Set();
            
            // For each borehole marker, check which zone it's in
            boreholeMarkers.forEach((grabCircle) => {
                const latlng = grabCircle.getLatLng();
                const boreholePoint = [latlng.lng, latlng.lat]; // [lon, lat] for GeoJSON
                const markerGroup = grabCircle.markerGroup;
                const boreholeIndex = grabCircle.boreholeIndex;
                
                // Check if borehole is in any hidden zone
                let shouldHide = false;
                for (const feature of zonesData.features) {
                    const zoneName = feature.properties?.zone_name || feature.properties?.display_name;
                    if (zoneVisibility[zoneName] === false) {
                        // Check if point is inside this zone polygon
                        if (isPointInPolygon(boreholePoint, feature.geometry)) {
                            shouldHide = true;
                            break;
                        }
                    }
                }
                
                // Show/hide the marker
                if (shouldHide) {
                    markerGroup.remove();
                    hiddenBoreholeIndices.add(boreholeIndex);
                } else {
                    if (!map.hasLayer(markerGroup)) {
                        boreholesLayer.addLayer(markerGroup);
                    }
                }
            });
            
            // Update coverage layer visibility based on borehole visibility
            coverageLayer.eachLayer((layer) => {
                const props = layer.feature?.properties;
                if (props && props.borehole_index !== undefined) {
                    if (hiddenBoreholeIndices.has(props.borehole_index)) {
                        layer.setStyle({ opacity: 0, fillOpacity: 0 });
                    } else {
                        // Restore normal style from config or defaults
                        const style = CONFIG?.proposedCoverageStyle || {};
                        layer.setStyle({
                            opacity: style.opacity || 0.8,
                            fillOpacity: style.fill_opacity || 0.25
                        });
                    }
                }
            });
        }
        
        // Simple point-in-polygon test for GeoJSON geometry
        function isPointInPolygon(point, geometry) {
            if (geometry.type === 'Polygon') {
                return pointInPolygonRing(point, geometry.coordinates[0]);
            } else if (geometry.type === 'MultiPolygon') {
                for (const polygon of geometry.coordinates) {
                    if (pointInPolygonRing(point, polygon[0])) {
                        return true;
                    }
                }
            }
            return false;
        }
        
        // Ray casting algorithm for point in polygon
        function pointInPolygonRing(point, ring) {
            const [x, y] = point;
            let inside = false;
            
            for (let i = 0, j = ring.length - 1; i < ring.length; j = i++) {
                const [xi, yi] = ring[i];
                const [xj, yj] = ring[j];
                
                if (((yi > y) !== (yj > y)) && (x < (xj - xi) * (y - yi) / (yj - yi) + xi)) {
                    inside = !inside;
                }
            }
            
            return inside;
        }
        
        async function updateDataTimestamp() {
            const dataInfo = await fetchDataInfo();
            if (!dataInfo) return;
            
            const container = document.getElementById('dataTimestamp');
            
            if (dataInfo.data_file_modified) {
                // Parse ISO date and format for display
                const modifiedDate = new Date(dataInfo.data_file_modified);
                const formattedDate = modifiedDate.toLocaleString('en-GB', {
                    day: '2-digit',
                    month: 'short',
                    year: 'numeric',
                    hour: '2-digit',
                    minute: '2-digit'
                });
                container.innerHTML = `üìÅ Data from: ${formattedDate}`;
            } else {
                container.innerHTML = '';
            }
            
            // Check for timestamp warning and show alert if files are out of sync
            if (dataInfo.timestamp_warning) {
                const warning = dataInfo.timestamp_warning;
                container.innerHTML += ` <span style="color: #e74c3c; cursor: pointer;" title="Click for details" onclick="showTimestampWarning()">‚ö†Ô∏è ${warning.diff_hours}h diff</span>`;
                
                // Store warning details globally for the popup
                window.timestampWarning = warning;
            }
            
            // Log source files to console for debugging
            if (dataInfo.source_files && dataInfo.source_files.length > 0) {
                console.log('üìÅ Source files:');
                dataInfo.source_files.forEach(f => {
                    console.log(`   ${f.type}: ${f.name} (${f.display})`);
                });
            }
        }
        
        function showTimestampWarning() {
            if (!window.timestampWarning) return;
            const w = window.timestampWarning;
            alert(`‚ö†Ô∏è Source File Timestamp Mismatch\n\n` +
                  `${w.message}\n\n` +
                  `Oldest: ${w.oldest.name}\n  (${w.oldest.display})\n\n` +
                  `Newest: ${w.newest.name}\n  (${w.newest.display})\n\n` +
                  `Recommendation: Re-run main.py to regenerate all files.`);
        }
        
        function renderZones(geojson) {
            zonesLayer.clearLayers();
            zonesLayer.addData(geojson);
            
            // Update info panel
            document.getElementById('zoneCount').textContent = geojson.features.length;
        }
        
        // Borehole marker configuration (meters) - fallback values, use CONFIG if available
        function getBoreholeVisibleRadius() {
            return (CONFIG && CONFIG.boreholeMarker) ? CONFIG.boreholeMarker.visible_radius_m : 8;
        }
        
        function getBoreholeGrabRadius() {
            return (CONFIG && CONFIG.boreholeMarker) ? CONFIG.boreholeMarker.grab_radius_m : 24;
        }
        
        function getBoreholeColor() {
            return (CONFIG && CONFIG.boreholeMarker) ? CONFIG.boreholeMarker.color : '#000000';
        }
        
        function renderBoreholes(geojson) {
            boreholesLayer.clearLayers();
            boreholeMarkers = [];
            
            const visibleRadius = getBoreholeVisibleRadius();
            const grabRadius = getBoreholeGrabRadius();
            const markerColor = getBoreholeColor();
            
            geojson.features.forEach((feature, index) => {
                const coords = feature.geometry.coordinates;
                const [lon, lat] = coords;
                const latlng = [lat, lon];
                
                const boreholeId = feature.properties.location_id || `PROP_${index}`;
                
                // Check if this borehole should be hidden based on zone visibility
                const boreholePoint = [lon, lat]; // [lon, lat] for GeoJSON
                let shouldHide = false;
                if (zonesData) {
                    for (const zoneFeature of zonesData.features) {
                        const zoneName = zoneFeature.properties?.zone_name || zoneFeature.properties?.display_name;
                        if (zoneVisibility[zoneName] === false) {
                            // Check if point is inside this hidden zone
                            if (isPointInPolygon(boreholePoint, zoneFeature.geometry)) {
                                shouldHide = true;
                                break;
                            }
                        }
                    }
                }
                
                // Create invisible grab circle (larger, for easier dragging)
                const grabCircle = L.circle(latlng, {
                    radius: grabRadius,
                    color: 'transparent',
                    fillColor: 'transparent',
                    fillOpacity: 0,
                    weight: 0,
                    interactive: true,
                    bubblingMouseEvents: false
                });
                
                // Create visible dot circle (smaller, black)
                const visibleCircle = L.circle(latlng, {
                    radius: visibleRadius,
                    color: markerColor,
                    fillColor: markerColor,
                    fillOpacity: 1,
                    weight: 0,
                    interactive: false  // Events handled by grab circle
                });
                
                // Group them together
                const markerGroup = L.layerGroup([grabCircle, visibleCircle]);
                
                // Store metadata on grab circle (which handles events)
                grabCircle.boreholeIndex = index;
                grabCircle.boreholeId = boreholeId;
                grabCircle.visibleCircle = visibleCircle;
                grabCircle.markerGroup = markerGroup;
                
                // Hover effects for better visual feedback
                const hoverScale = CONFIG?.borehole_marker?.hover_scale || 2.0;  // From config or default
                let isDragging = false;  // Track drag state for hover effects
                
                grabCircle.on('mouseover', () => {
                    if (!isDragging) {
                        visibleCircle.setRadius(visibleRadius * hoverScale);
                        map.getContainer().style.cursor = 'grab';
                    }
                });
                
                grabCircle.on('mouseout', () => {
                    if (!isDragging) {
                        visibleCircle.setRadius(visibleRadius);
                        map.getContainer().style.cursor = '';
                    }
                });
                
                // Custom drag handling
                let dragStartLatLng = null;
                
                grabCircle.on('mousedown', (e) => {
                    if (e.originalEvent.shiftKey) return; // Don't start drag on shift+click
                    
                    isDragging = true;
                    dragStartLatLng = grabCircle.getLatLng();
                    
                    // Save state BEFORE dragging for undo
                    saveStateForUndo();
                    
                    // Disable map dragging
                    map.dragging.disable();
                    
                    // Change cursor
                    map.getContainer().style.cursor = 'grabbing';
                    
                    // Handle mouse move on map
                    map.on('mousemove', onDragMove);
                    map.on('mouseup', onDragEnd);
                });
                
                function onDragMove(e) {
                    if (!isDragging) return;
                    
                    const newLatLng = e.latlng;
                    grabCircle.setLatLng(newLatLng);
                    visibleCircle.setLatLng(newLatLng);
                }
                
                async function onDragEnd(e) {
                    if (!isDragging) return;
                    
                    isDragging = false;
                    map.dragging.enable();
                    map.getContainer().style.cursor = '';
                    
                    // Remove event listeners
                    map.off('mousemove', onDragMove);
                    map.off('mouseup', onDragEnd);
                    
                    const newLatLng = grabCircle.getLatLng();
                    
                    // Only update if position actually changed
                    if (newLatLng.lat !== dragStartLatLng.lat || newLatLng.lng !== dragStartLatLng.lng) {
                        const result = await updateBoreholePosition(
                            grabCircle.boreholeIndex,
                            newLatLng.lng,
                            newLatLng.lat
                        );
                        
                        if (result) {
                            // Update local data
                            boreholesData.features[grabCircle.boreholeIndex].geometry.coordinates = [newLatLng.lng, newLatLng.lat];
                            
                            // Update single coverage polygon (handles null coverage for points outside zones)
                            updateSingleCoverage(grabCircle.boreholeIndex, result.coverage);
                            
                            // Update info panel
                            showBoreholeInfo(grabCircle, result.zone_info);
                            
                            // Refresh coverage stats
                            await refreshCoverageStats();
                        }
                    }
                }
                
                // Shift+Click to delete
                grabCircle.on('click', async (e) => {
                    if (e.originalEvent.shiftKey) {
                        // Save state for undo before deleting
                        saveStateForUndo();
                        
                        const result = await deleteBorehole(grabCircle.boreholeIndex);
                        if (result && result.success) {
                            // Update local data
                            boreholesData = result.boreholes;
                            
                            // Re-render boreholes with new indices
                            renderBoreholes(boreholesData);
                            
                            // Refresh all coverages
                            const coverages = await fetchAllCoverages();
                            renderCoverages(coverages);
                            
                            // Re-apply zone visibility after re-rendering
                            updateBoreholeVisibilityForZones();
                            
                            // Refresh coverage stats
                            await refreshCoverageStats();
                            
                            console.log(`üóëÔ∏è Deleted borehole ${grabCircle.boreholeId}`);
                        }
                    } else {
                        showBoreholeInfo(grabCircle, null);
                    }
                });
                
                // Only add to map if not in a hidden zone
                if (!shouldHide) {
                    markerGroup.addTo(boreholesLayer);
                }
                boreholeMarkers.push(grabCircle);  // Always store for reference (needed for visibility toggling)
            });
            
            // Update info panel
            document.getElementById('boreholeCount').textContent = geojson.features.length;
        }
        
        function renderCoverages(geojson) {
            coverageLayer.clearLayers();
            coverageLayer.addData(geojson);
        }
        
        function renderExistingCoverage(geojson) {
            existingCoverageLayer.clearLayers();
            if (geojson && geojson.features && geojson.features.length > 0) {
                existingCoverageLayer.addData(geojson);
                
                // Apply style from config (must be after addData since setStyle only affects existing features)
                if (CONFIG && CONFIG.existingCoverageStyle) {
                    const style = CONFIG.existingCoverageStyle;
                    existingCoverageLayer.setStyle({
                        color: style.color || '#27ae60',
                        weight: style.weight || 2,
                        opacity: style.opacity || 0.7,
                        fillColor: style.fill_color || '#2ecc71',
                        fillOpacity: style.fill_opacity || 0.35
                    });
                    console.log(`üé® Applied existing coverage style: fillColor=${style.fill_color}`);
                }
                
                console.log(`‚úÖ Rendered ${geojson.features.length} existing coverage polygons`);
            }
        }
        
        function updateSingleCoverage(boreholeIndex, coverage) {
            // Remove ALL coverages for this borehole (handle potential duplicates)
            const toRemove = [];
            coverageLayer.eachLayer(layer => {
                const props = layer.feature?.properties;
                if (props && props.borehole_index === boreholeIndex) {
                    toRemove.push(layer);
                }
            });
            toRemove.forEach(layer => coverageLayer.removeLayer(layer));
            
            // Add new coverage if valid
            if (coverage && coverage.geometry) {
                coverage.properties = coverage.properties || {};
                coverage.properties.borehole_index = boreholeIndex;
                coverageLayer.addData(coverage);
            }
        }
        
        function showBoreholeInfo(marker, zoneInfo) {
            const panel = document.getElementById('selectedBorehole');
            panel.style.display = 'block';
            
            document.getElementById('selectedId').textContent = marker.boreholeId;
            
            if (zoneInfo) {
                const zones = Object.keys(zoneInfo);
                document.getElementById('selectedZone').textContent = zones.join(', ') || 'Outside zones';
                
                const radii = Object.values(zoneInfo);
                document.getElementById('selectedRadius').textContent = 
                    radii.length > 0 ? radii.map(r => `${r}m`).join(', ') : '-';
            } else {
                document.getElementById('selectedZone').textContent = '-';
                document.getElementById('selectedRadius').textContent = '-';
            }
        }
        
        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        // üöÄ INITIALIZATION
        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        
        function applyConfig() {
            // Apply configuration to layer styles and variables
            if (!CONFIG) return;
            
            // Update zone colors from config
            if (CONFIG.zoneColors) {
                zoneColors = CONFIG.zoneColors;
            }
            
            // Update base layer opacity
            if (CONFIG.map && CONFIG.map.base_layer_opacity !== undefined) {
                baseLayer.setOpacity(CONFIG.map.base_layer_opacity);
            }
            
            // Update zone polygon style from config
            if (CONFIG.zonePolygonStyle) {
                const style = CONFIG.zonePolygonStyle;
                zonesLayer.setStyle({
                    color: style.color || '#666666',
                    weight: style.weight || 3,
                    opacity: style.opacity || 0.8,
                    fillColor: style.fill_color || '#ffffff',
                    fillOpacity: style.fill_opacity || 1.0
                });
            }
            
            // Update existing coverage style from config
            if (CONFIG.existingCoverageStyle) {
                const style = CONFIG.existingCoverageStyle;
                existingCoverageLayer.setStyle({
                    color: style.color || '#27ae60',
                    weight: style.weight || 2,
                    opacity: style.opacity || 0.7,
                    fillColor: style.fill_color || '#2ecc71',
                    fillOpacity: style.fill_opacity || 0.35
                });
            }
            
            // Apply coverage panel width from config
            if (CONFIG.ui && CONFIG.ui.coverage_panel_width_px) {
                document.documentElement.style.setProperty(
                    '--coverage-panel-width', 
                    CONFIG.ui.coverage_panel_width_px + 'px'
                );
            }
            
            // Apply progress bar width from config
            if (CONFIG.ui && CONFIG.ui.coverage_progress_bar_width_px) {
                document.documentElement.style.setProperty(
                    '--coverage-progress-bar-width', 
                    CONFIG.ui.coverage_progress_bar_width_px + 'px'
                );
            }
            
            console.log('üìã Config applied:', CONFIG);
        }
        
        async function initialize() {
            const loadingOverlay = document.getElementById('loadingOverlay');
            
            try {
                // Load config first
                CONFIG = await fetchConfig();
                if (CONFIG) {
                    applyConfig();
                }
                
                // Load zones
                zonesData = await fetchZones();
                renderZones(zonesData);
                
                // Load existing coverage (green, from main.py output)
                const existingCoverage = await fetchExistingCoverage();
                renderExistingCoverage(existingCoverage);
                
                // Load boreholes
                boreholesData = await fetchBoreholes();
                originalBoreholesData = JSON.parse(JSON.stringify(boreholesData));  // Save initial state for reset
                renderBoreholes(boreholesData);
                
                // Load initial coverages (blue, proposed)
                const coverages = await fetchAllCoverages();
                renderCoverages(coverages);
                
                // Load coverage stats
                await refreshCoverageStats();
                
                // Load data timestamp
                await updateDataTimestamp();
                
                // Fit map to zones bounds
                if (zonesLayer.getBounds().isValid()) {
                    map.fitBounds(zonesLayer.getBounds(), { padding: [20, 20] });
                }
                
                console.log('‚úÖ Initialization complete');
                
            } catch (error) {
                console.error('‚ùå Initialization failed:', error);
                alert('Failed to load data. Check console for details.');
            } finally {
                loadingOverlay.style.display = 'none';
            }
        }
        
        // Start initialization
        initialize();
        
        // Toggle base map visibility
        document.getElementById('toggleBaseMap').addEventListener('change', function() {
            if (this.checked) {
                baseLayer.setOpacity(0.25);
            } else {
                baseLayer.setOpacity(0);
            }
        });
        
        // Toggle left panel (Coverage by Zone)
        document.getElementById('leftPanelToggle').addEventListener('click', function() {
            const panel = document.getElementById('leftPanel');
            const toggleBtn = this;
            
            panel.classList.toggle('collapsed');
            toggleBtn.classList.toggle('panel-open');
        });
        
        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        // üîò BUTTON HANDLERS
        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        
        // Undo button
        document.getElementById('undoBtn').addEventListener('click', performUndo);
        
        // Reset button
        document.getElementById('resetBtn').addEventListener('click', performReset);
        
        // Export CSV button
        document.getElementById('exportCsvBtn').addEventListener('click', function() {
            window.location.href = '/api/boreholes/export';
        });
        
        // Add borehole button
        document.getElementById('addBoreholeBtn').addEventListener('click', function() {
            addBoreholeMode = !addBoreholeMode;
            
            const btn = this;
            const indicator = document.getElementById('addModeIndicator');
            
            if (addBoreholeMode) {
                btn.classList.add('active');
                btn.textContent = '‚úï Cancel';
                indicator.style.display = 'block';
                map.getContainer().style.cursor = 'crosshair';
            } else {
                btn.classList.remove('active');
                btn.textContent = '+ Add Borehole';
                indicator.style.display = 'none';
                map.getContainer().style.cursor = '';
            }
        });
        
        // ESC key to cancel add mode
        document.addEventListener('keydown', function(e) {
            if (e.key === 'Escape' && addBoreholeMode) {
                document.getElementById('addBoreholeBtn').click();
            }
        });
        
        // Map click handler for adding boreholes
        map.on('click', async function(e) {
            if (!addBoreholeMode) return;
            
            const lat = e.latlng.lat;
            const lon = e.latlng.lng;
            
            // Save state for undo
            saveStateForUndo();
            
            // Add the borehole
            const result = await addNewBorehole(lon, lat);
            
            if (result && result.success) {
                // Update local data
                boreholesData = result.boreholes;
                
                // Re-render all boreholes
                renderBoreholes(boreholesData);
                
                // Add the new coverage
                if (result.coverage) {
                    result.coverage.properties = result.coverage.properties || {};
                    result.coverage.properties.borehole_index = result.index;
                    coverageLayer.addData(result.coverage);
                }
                
                // Re-apply zone visibility after re-rendering
                updateBoreholeVisibilityForZones();
                
                // Refresh coverage stats
                await refreshCoverageStats();
                
                console.log(`‚ûï Added borehole at (${lon.toFixed(6)}, ${lat.toFixed(6)})`);
            }
            
            // Exit add mode after adding
            document.getElementById('addBoreholeBtn').click();
        });
    </script>
</body>
</html>
