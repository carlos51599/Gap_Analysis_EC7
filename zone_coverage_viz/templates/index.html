<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Zone Coverage Visualization</title>
    
    <!-- Leaflet CSS -->
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
    
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
        }
        
        #map {
            width: 100%;
            height: 100vh;
            background: #f5f5f5;
        }
        
        .info-panel {
            position: absolute;
            top: 10px;
            right: 10px;
            z-index: 1000;
            background: white;
            padding: 15px;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.2);
            max-width: 300px;
            font-size: 14px;
        }
        
        .info-panel h3 {
            margin-bottom: 10px;
            color: #333;
        }
        
        .info-panel .stat {
            display: flex;
            justify-content: space-between;
            margin-bottom: 5px;
        }
        
        .info-panel .stat-label {
            color: #666;
        }
        
        .info-panel .stat-value {
            font-weight: bold;
            color: #333;
        }
        
        .info-panel .divider {
            border-top: 1px solid #eee;
            margin: 10px 0;
        }
        
        .zone-legend {
            margin-top: 10px;
        }
        
        .zone-legend-item {
            display: flex;
            align-items: center;
            margin-bottom: 5px;
        }
        
        .zone-legend-color {
            width: 16px;
            height: 16px;
            margin-right: 8px;
            border-radius: 3px;
        }
        
        .loading-overlay {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(255,255,255,0.9);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 2000;
        }
        
        .loading-spinner {
            text-align: center;
        }
        
        .loading-spinner .spinner {
            width: 40px;
            height: 40px;
            border: 4px solid #f3f3f3;
            border-top: 4px solid #3498db;
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin: 0 auto 10px;
        }
        
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        
        .toggle-row {
            margin: 5px 0;
        }
        
        .toggle-label {
            display: flex;
            align-items: center;
            cursor: pointer;
            font-size: 13px;
        }
        
        .toggle-label input {
            margin-right: 8px;
            cursor: pointer;
        }
        
        .action-buttons {
            margin-top: 10px;
            display: flex;
            gap: 8px;
            flex-wrap: wrap;
        }
        
        .action-btn {
            padding: 8px 12px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 12px;
            font-weight: 500;
            transition: background 0.2s, opacity 0.2s;
        }
        
        .action-btn:hover {
            opacity: 0.9;
        }
        
        .action-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }
        
        .btn-undo {
            background: #95a5a6;
            color: white;
        }
        
        .btn-add {
            background: #27ae60;
            color: white;
        }
        
        .btn-add.active {
            background: #e74c3c;
        }
        
        .btn-reset {
            background: #3498db;
            color: white;
        }
        
        .btn-export {
            background: #9b59b6;
            color: white;
            width: 100%;
        }
        
        .add-mode-indicator {
            position: absolute;
            top: 50px;
            left: 50%;
            transform: translateX(-50%);
            background: #27ae60;
            color: white;
            padding: 10px 20px;
            border-radius: 20px;
            font-size: 14px;
            font-weight: bold;
            z-index: 1000;
            box-shadow: 0 2px 10px rgba(0,0,0,0.3);
            display: none;
        }
        
        .help-text {
            font-size: 11px;
            color: #888;
            margin-top: 8px;
            line-height: 1.4;
        }
        
        .delete-hint {
            display: block;
            width: 100%;
            background: #e74c3c;
            color: white;
            padding: 6px 12px;
            border-radius: 20px;
            font-size: 11px;
            font-weight: 500;
            text-align: center;
            box-sizing: border-box;
        }
        
        .coverage-stats {
            margin-top: 10px;
            padding: 10px;
            background: white;
            border-radius: 6px;
        }
        
        .coverage-stats h4 {
            margin: 0 0 8px 0;
            font-size: 12px;
            color: #333;
        }
        
        .coverage-stats .stat-row {
            display: flex;
            align-items: center;
            margin-bottom: 6px;
            font-size: 13px;
            gap: 8px;
        }
        
        .coverage-stats .zone-checkbox {
            width: 14px;
            height: 14px;
            cursor: pointer;
            flex-shrink: 0;
        }
        
        .coverage-stats .zone-name {
            color: #333;
            flex: 1;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }
        
        .coverage-stats .pct-value {
            font-weight: bold;
            min-width: 45px;
            text-align: right;
            flex-shrink: 0;
        }
        
        .coverage-stats .pct-good { color: #27ae60; }
        .coverage-stats .pct-medium { color: #f39c12; }
        .coverage-stats .pct-poor { color: #e74c3c; }
        
        .coverage-stats .progress-bar {
            width: var(--coverage-progress-bar-width, 100px);
            flex-shrink: 0;
            height: 6px;
            background: #e0e0e0;
            border-radius: 3px;
            margin: 0 8px;
            overflow: hidden;
        }
        
        .coverage-stats .progress-fill {
            height: 100%;
            border-radius: 3px;
            transition: width 0.3s ease;
        }
        
        .coverage-stats .total-row {
            border-top: 1px solid #ddd;
            padding-top: 8px;
            margin-top: 8px;
            font-weight: bold;
        }
        
        .coverage-stats .total-row .progress-bar {
            flex: 1;
            width: auto;
        }
        
        /* Hierarchical zone groups */
        .coverage-stats .zone-group {
            margin-bottom: 6px;
        }
        
        .coverage-stats .group-header {
            display: flex;
            align-items: center;
            gap: 6px;
            cursor: pointer;
            padding: 4px 0;
            font-weight: bold;
            color: #333;
            user-select: none;
        }
        
        .coverage-stats .group-header:hover {
            background: #f5f5f5;
            border-radius: 3px;
        }
        
        .coverage-stats .group-toggle {
            width: 16px;
            height: 16px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 10px;
            color: #666;
            flex-shrink: 0;
            transition: transform 0.15s ease;
        }
        
        .coverage-stats .group-toggle.collapsed {
            transform: rotate(-90deg);
        }
        
        .coverage-stats .group-checkbox {
            width: 14px;
            height: 14px;
            cursor: pointer;
            flex-shrink: 0;
        }
        
        .coverage-stats .group-name {
            flex: 1;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }
        
        .coverage-stats .group-pct {
            font-weight: bold;
            min-width: 45px;
            text-align: right;
            flex-shrink: 0;
        }
        
        .coverage-stats .group-children {
            margin-left: 22px;
            overflow: hidden;
            transition: max-height 0.2s ease;
        }
        
        .coverage-stats .group-children.collapsed {
            max-height: 0 !important;
        }
        
        .coverage-stats .group-children .stat-row {
            font-size: 12px;
        }
        
        .coverage-stats .group-children .zone-name {
            font-weight: normal;
        }
        
        .data-timestamp {
            font-size: 10px;
            color: #888;
            margin-top: 8px;
            padding-top: 6px;
            border-top: 1px solid #eee;
        }
        
        /* ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
           LEFT PANEL - Coverage by Zone (collapsible)
           ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê */
        
        .left-panel {
            position: absolute;
            top: 10px;
            left: 10px;
            z-index: 1000;
            background: white;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.2);
            width: var(--coverage-panel-width, 320px);
            font-size: 14px;
            transition: transform 0.3s ease, opacity 0.3s ease;
        }
        
        .left-panel.collapsed {
            transform: translateX(-100%);
            opacity: 0;
            pointer-events: none;
        }
        
        .left-panel-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 12px 15px;
            border-bottom: 1px solid #eee;
            background: white;
            border-radius: 8px 8px 0 0;
        }
        
        .left-panel-header h4 {
            margin: 0;
            font-size: 14px;
            color: #333;
        }
        
        .left-panel-content {
            padding: 15px;
            max-height: calc(100vh - 150px);
            overflow-y: auto;
        }
        
        .panel-toggle-btn {
            position: absolute;
            top: 10px;
            left: 10px;
            z-index: 1001;
            width: 32px;
            height: 32px;
            background: white;
            border: none;
            border-radius: 6px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.2);
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 14px;
            transition: transform 0.3s ease, left 0.3s ease;
        }
        
        .panel-toggle-btn:hover {
            background: #f5f5f5;
        }
        
        .panel-toggle-btn.panel-open {
            left: calc(var(--coverage-panel-width, 320px) + 15px);  /* Position next to expanded panel */
        }
        
        .panel-toggle-btn .arrow {
            transition: transform 0.3s ease;
        }
        
        .panel-toggle-btn.panel-open .arrow {
            transform: rotate(180deg);
        }
    </style>
</head>
<body>
    <div id="map"></div>
    
    <!-- Left Panel Toggle Button -->
    <button class="panel-toggle-btn panel-open" id="leftPanelToggle" title="Toggle Coverage Panel">
        <span class="arrow">‚ñ∂</span>
    </button>
    
    <!-- Left Panel - Coverage by Zone -->
    <div class="left-panel" id="leftPanel">
        <div class="left-panel-header">
            <h4>Coverage by Zone</h4>
        </div>
        <div class="left-panel-content coverage-stats">
            <div id="coverageStatsContent">
                <span style="color: #888; font-size: 11px;">Loading...</span>
            </div>
            <div class="data-timestamp" id="dataTimestamp"></div>
        </div>
    </div>
    
    <div class="add-mode-indicator" id="addModeIndicator">
        üìç Click on map to add borehole (ESC to cancel)
    </div>
    
    <div class="info-panel" id="infoPanel">
        <h3>Overview</h3>
        <div class="stat">
            <span class="stat-label">Boreholes:</span>
            <span class="stat-value" id="boreholeCount">-</span>
        </div>
        <div class="stat">
            <span class="stat-label">Zones:</span>
            <span class="stat-value" id="zoneCount">-</span>
        </div>
        <div class="divider"></div>
        <div class="action-buttons">
            <button class="action-btn btn-undo" id="undoBtn" disabled title="Undo last action">
                ‚Ü© Undo
            </button>
            <button class="action-btn btn-add" id="addBoreholeBtn" title="Add new borehole">
                + Add Borehole
            </button>
            <button class="action-btn btn-reset" id="resetBtn" title="Reset to original positions">
                ‚ü≤ Reset
            </button>
        </div>
        <div class="help-text">
            <span class="delete-hint">Shift+Click on borehole to delete</span>
        </div>
        <div class="divider"></div>
        <div class="toggle-row">
            <label class="toggle-label">
                <input type="checkbox" id="toggleBaseMap" checked>
                <span>Show Background Map</span>
            </label>
        </div>
        <div class="divider"></div>
        <div id="selectedBorehole" style="display: none;">
            <h4 style="margin-bottom: 5px;">Selected Borehole</h4>
            <div class="stat">
                <span class="stat-label">ID:</span>
                <span class="stat-value" id="selectedId">-</span>
            </div>
            <div class="stat">
                <span class="stat-label">Zone:</span>
                <span class="stat-value" id="selectedZone">-</span>
            </div>
            <div class="stat">
                <span class="stat-label">Radius:</span>
                <span class="stat-value" id="selectedRadius">-</span>
            </div>
        </div>
        <div class="divider"></div>
        <div class="action-buttons">
            <button class="action-btn btn-export" id="exportCsvBtn" title="Export borehole coordinates to CSV">
                üì• Export CSV
            </button>
        </div>
    </div>
    
    <div class="loading-overlay" id="loadingOverlay">
        <div class="loading-spinner">
            <div class="spinner"></div>
            <div>Loading data...</div>
        </div>
    </div>
    
    <!-- Leaflet JS -->
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
    
    <script>
        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        // ÔøΩ CONFIGURATION (loaded from server)
        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        
        let CONFIG = null;  // Loaded from /api/config at startup
        
        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        // üó∫Ô∏è MAP INITIALIZATION
        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        
        // Initialize map (centered on UK) - will be re-centered after data loads
        const map = L.map('map', { zoomControl: false }).setView([51.5, -1.0], 14);
        
        // Add base layer (OpenStreetMap) with very reduced opacity
        const baseLayer = L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
            attribution: '&copy; OpenStreetMap contributors',
            opacity: 0.25
        }).addTo(map);
        
        // Layer groups - initialized with default styles, updated after config loads
        let zonesLayer = L.geoJSON(null, {
            style: {
                color: '#666666',
                weight: 3,
                opacity: 0.8,
                fillColor: '#ffffff',
                fillOpacity: 1
            },
            interactive: true,  // Enable interaction for tooltips
            onEachFeature: (feature, layer) => {
                const props = feature.properties || {};
                const zoneName = props.zone_name || props.display_name || 'Zone';
                // Bind tooltip that follows cursor along the geometry
                layer.bindTooltip(zoneName, {
                    permanent: false,
                    sticky: true,  // Follow the cursor
                    className: 'zone-tooltip'
                });
                // Prevent click from showing bounding box - instead highlight actual geometry
                layer.on('click', (e) => {
                    L.DomEvent.stopPropagation(e);  // Don't propagate to map
                });
            }
        });
        
        // Existing borehole coverage (green, below proposed)
        // Note: Style will be updated from CONFIG after data is loaded in renderExistingCoverage()
        const existingCoverageLayer = L.geoJSON(null, {
            style: {
                color: '#27ae60',
                weight: 2,
                opacity: 0.8,
                fillColor: '#5feb5f',  // Matches ec7_coverage.html: rgba(95, 235, 95, 0.85)
                fillOpacity: 0.85
            },
            interactive: false  // Let mouse events pass through to boreholes
        });
        
        const coverageLayer = L.geoJSON(null, {
            style: {
                color: '#2980b9',
                weight: 3,
                opacity: 0.8,
                fillColor: '#3498db',
                fillOpacity: 0.25
            },
            interactive: false  // Let mouse events pass through to boreholes
        });
        
        const boreholesLayer = L.layerGroup();
        
        // Add layers to map in order (zones at bottom, existing coverage, proposed coverage, boreholes on top)
        zonesLayer.addTo(map);
        existingCoverageLayer.addTo(map);
        coverageLayer.addTo(map);
        boreholesLayer.addTo(map);

        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        // üìä DATA STORAGE
        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        
        let boreholeMarkers = [];
        let zonesData = null;
        let boreholesData = null;
        let originalBoreholesData = null;  // Store initial state for reset
        
        // Zone visibility state: { "zone_name": true/false }
        let zoneVisibility = {};
        
        // NOTE: We no longer use hiddenBoreholesPerZone - zone associations are
        // pre-computed by server as zone_ids in each borehole's properties.
        // This is the single source of truth for zone-borehole relationships.
        
        // Undo history stack
        let undoHistory = [];
        const MAX_UNDO_HISTORY = 50;
        
        // Add borehole mode
        let addBoreholeMode = false;
        
        // Zone colors
        // Zone colors - loaded from config, fallback here
        let zoneColors = {
            'Embankment': '#e74c3c',
            'Highways': '#3498db'
        };
        
        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        // üéØ VISIBILITY HELPERS (Generic for any future filters)
        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        // 
        // IMPORTANT FOR FUTURE DEVELOPERS:
        // These helpers detect visible boreholes by checking if markers are on the map.
        // To ensure your filter works with the borehole count and CSV export:
        //
        // ‚úÖ CORRECT - Use Leaflet layer management:
        //    To hide: markerGroup.remove() OR boreholesLayer.removeLayer(markerGroup)
        //    To show: boreholesLayer.addLayer(markerGroup)
        //
        // ‚ùå WRONG - These approaches will NOT work:
        //    - CSS visibility (opacity: 0, display: none)
        //    - Moving markers off-screen
        //    - Separate tracking without layer removal
        //
        // Zone visibility uses pre-computed zone_ids from server (single source of truth).
        // See toggleZoneVisibility() for reference implementation.
        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        
        /**
         * Get indices of all currently visible boreholes on the map.
         * This is filter-agnostic - works with any current or future filtering mechanism.
         * @returns {number[]} Array of visible borehole indices
         */
        function getVisibleBoreholeIndices() {
            const visibleIndices = [];
            boreholeMarkers.forEach((grabCircle) => {
                // Check if the marker's group is actually on the map
                if (grabCircle.markerGroup && map.hasLayer(grabCircle.markerGroup)) {
                    visibleIndices.push(grabCircle.boreholeIndex);
                }
            });
            return visibleIndices;
        }
        
        /**
         * Get indices of all hidden boreholes (not on map).
         * @returns {number[]} Array of hidden borehole indices
         */
        function getHiddenBoreholeIndices() {
            const hiddenIndices = [];
            boreholeMarkers.forEach((grabCircle) => {
                if (!grabCircle.markerGroup || !map.hasLayer(grabCircle.markerGroup)) {
                    hiddenIndices.push(grabCircle.boreholeIndex);
                }
            });
            return hiddenIndices;
        }
        
        /**
         * Check if a borehole should be visible based on zone visibility state.
         * Uses pre-computed zone_ids from server (single source of truth).
         * 
         * Rule: Borehole is hidden if ANY of its containing zones is hidden.
         * 
         * @param {Array<string>} zoneIds - Array of zone names containing this borehole
         * @returns {boolean} - True if borehole should be visible
         */
        function isBoreholeVisibleByZones(zoneIds) {
            if (!zoneIds || zoneIds.length === 0) {
                return true; // Borehole not in any zone = always visible
            }
            // Hidden if ANY zone is hidden
            return !zoneIds.some(zid => zoneVisibility[zid] === false);
        }
        
        /**
         * Update the borehole count display in the info panel.
         * Shows "visible/total" when filtered, or just "total" when all visible.
         */
        function updateBoreholeCountDisplay() {
            const totalCount = boreholeMarkers.length;
            const visibleCount = getVisibleBoreholeIndices().length;
            const countElement = document.getElementById('boreholeCount');
            
            if (countElement) {
                countElement.textContent = visibleCount === totalCount 
                    ? `${totalCount}` 
                    : `${visibleCount}/${totalCount}`;
            }
        }

        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        // üîÑ API FUNCTIONS
        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        
        async function fetchConfig() {
            try {
                const response = await fetch('/api/config');
                const data = await response.json();
                return data;
            } catch (error) {
                console.error('Failed to fetch config:', error);
                return null;
            }
        }
        
        async function fetchDataInfo() {
            try {
                const response = await fetch('/api/data/info');
                const data = await response.json();
                return data;
            } catch (error) {
                console.error('Failed to fetch data info:', error);
                return null;
            }
        }
        
        async function fetchZones() {
            try {
                const response = await fetch('/api/zones');
                const data = await response.json();
                return data;
            } catch (error) {
                console.error('Failed to fetch zones:', error);
                return { type: 'FeatureCollection', features: [] };
            }
        }
        
        async function fetchBoreholes() {
            try {
                const response = await fetch('/api/boreholes');
                const data = await response.json();
                return data;
            } catch (error) {
                console.error('Failed to fetch boreholes:', error);
                return { type: 'FeatureCollection', features: [] };
            }
        }
        
        async function fetchAllCoverages() {
            try {
                const response = await fetch('/api/coverage/all');
                const data = await response.json();
                return data;
            } catch (error) {
                console.error('Failed to fetch coverages:', error);
                return { type: 'FeatureCollection', features: [] };
            }
        }
        
        async function fetchExistingCoverage() {
            try {
                const response = await fetch('/api/existing-coverage');
                const data = await response.json();
                return data;
            } catch (error) {
                console.error('Failed to fetch existing coverage:', error);
                return { type: 'FeatureCollection', features: [] };
            }
        }
        
        async function fetchCoverageStats() {
            try {
                const response = await fetch('/api/coverage/stats');
                const data = await response.json();
                return data;
            } catch (error) {
                console.error('Failed to fetch coverage stats:', error);
                return null;
            }
        }
        
        async function updateBoreholePosition(index, lon, lat) {
            try {
                const response = await fetch('/api/coverage/update', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ index, lon, lat })
                });
                const data = await response.json();
                return data;
            } catch (error) {
                console.error('Failed to update borehole:', error);
                return null;
            }
        }
        
        async function deleteBorehole(index) {
            try {
                const response = await fetch('/api/borehole/delete', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ index })
                });
                const data = await response.json();
                return data;
            } catch (error) {
                console.error('Failed to delete borehole:', error);
                return null;
            }
        }
        
        async function restoreBoreholes(boreholesGeojson) {
            try {
                const response = await fetch('/api/borehole/restore', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ boreholes: boreholesGeojson })
                });
                const data = await response.json();
                return data;
            } catch (error) {
                console.error('Failed to restore boreholes:', error);
                return null;
            }
        }
        
        async function addNewBorehole(lon, lat, locationId = null) {
            try {
                const body = { lon, lat };
                if (locationId) body.location_id = locationId;
                
                const response = await fetch('/api/borehole/add', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(body)
                });
                const data = await response.json();
                return data;
            } catch (error) {
                console.error('Failed to add borehole:', error);
                return null;
            }
        }
        
        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        // üîÑ UNDO SYSTEM
        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        
        function saveStateForUndo() {
            // Deep clone current boreholes data
            const snapshot = JSON.parse(JSON.stringify(boreholesData));
            undoHistory.push(snapshot);
            
            // Limit history size
            if (undoHistory.length > MAX_UNDO_HISTORY) {
                undoHistory.shift();
            }
            
            updateUndoButton();
        }
        
        function updateUndoButton() {
            const undoBtn = document.getElementById('undoBtn');
            undoBtn.disabled = undoHistory.length === 0;
        }
        
        async function performUndo() {
            if (undoHistory.length === 0) return;
            
            const previousState = undoHistory.pop();
            boreholesData = previousState;
            
            // Sync restored state to server
            await restoreBoreholes(boreholesData);
            
            // Re-render boreholes
            renderBoreholes(boreholesData);
            
            // Re-compute coverages (now server has correct state) - includes stats
            const coveragesResponse = await fetchAllCoverages();
            renderCoverages(coveragesResponse);
            
            // Re-apply zone visibility after re-rendering
            updateBoreholeVisibilityForZones();
            
            updateUndoButton();
            console.log('‚Ü©Ô∏è Undo performed');
            
            // Render coverage stats from response (avoids extra API call)
            if (coveragesResponse.stats) {
                renderCoverageStats(coveragesResponse.stats);
            }
        }
        
        async function performReset() {
            if (!originalBoreholesData) return;
            
            // Restore to original state
            boreholesData = JSON.parse(JSON.stringify(originalBoreholesData));
            
            // Sync restored state to server
            await restoreBoreholes(boreholesData);
            
            // Re-render boreholes
            renderBoreholes(boreholesData);
            
            // Re-compute coverages - includes stats
            const coveragesResponse = await fetchAllCoverages();
            renderCoverages(coveragesResponse);
            
            // Re-apply zone visibility after re-rendering
            updateBoreholeVisibilityForZones();
            
            // Clear undo history
            undoHistory = [];
            updateUndoButton();
            console.log('üîÑ Reset to original state');
            
            // Render coverage stats from response (avoids extra API call)
            if (coveragesResponse.stats) {
                renderCoverageStats(coveragesResponse.stats);
            }
        }
        
        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        // üé® RENDERING FUNCTIONS
        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        
        function getCoverageStatsConfig() {
            return (CONFIG && CONFIG.coverageStats) ? CONFIG.coverageStats : {
                good_threshold: 90,
                medium_threshold: 50,
                good_color: '#27ae60',
                medium_color: '#f39c12',
                poor_color: '#e74c3c'
            };
        }
        
        function getPctClass(pct) {
            const cfg = getCoverageStatsConfig();
            if (pct >= cfg.good_threshold) return 'pct-good';
            if (pct >= cfg.medium_threshold) return 'pct-medium';
            return 'pct-poor';
        }
        
        function getPctColor(pct) {
            const cfg = getCoverageStatsConfig();
            if (pct >= cfg.good_threshold) return cfg.good_color;
            if (pct >= cfg.medium_threshold) return cfg.medium_color;
            return cfg.poor_color;
        }
        
        async function refreshCoverageStats() {
            const stats = await fetchCoverageStats();
            if (!stats) return;
            renderCoverageStats(stats);
        }
        
        // Render coverage stats directly (avoids extra API call when stats provided in response)
        function renderCoverageStats(stats) {
            if (!stats) return;
            
            const container = document.getElementById('coverageStatsContent');
            
            // Initialize zone visibility for any new zones (default to visible)
            for (const zone of stats.per_zone) {
                if (zoneVisibility[zone.zone_name] === undefined) {
                    zoneVisibility[zone.zone_name] = true;
                }
            }
            
            // Group zones by layer_key for hierarchical display
            const groupedZones = {};
            for (const zone of stats.per_zone) {
                const layerKey = zone.layer_key || 'unknown';
                const displayName = zone.layer_display_name || layerKey.replace(/_/g, ' ');
                if (!groupedZones[layerKey]) {
                    groupedZones[layerKey] = {
                        displayName: displayName,
                        zones: [],
                        totalArea: 0,
                        coveredArea: 0
                    };
                }
                groupedZones[layerKey].zones.push(zone);
                groupedZones[layerKey].totalArea += zone.total_area_m2;
                groupedZones[layerKey].coveredArea += zone.covered_area_m2;
            }
            
            // Build HTML for hierarchical per-zone stats
            let html = '';
            
            for (const [layerKey, group] of Object.entries(groupedZones)) {
                // Calculate group coverage percentage
                const groupPct = group.totalArea > 0 
                    ? Math.round((group.coveredArea / group.totalArea) * 1000) / 10 
                    : 0;
                const groupPctClass = getPctClass(groupPct);
                const groupPctColor = getPctColor(groupPct);
                
                // Check if all zones in group are visible
                const allVisible = group.zones.every(z => zoneVisibility[z.zone_name] !== false);
                const someVisible = group.zones.some(z => zoneVisibility[z.zone_name] !== false);
                
                html += `
                    <div class="zone-group" data-layer="${layerKey}">
                        <div class="group-header" onclick="toggleGroupExpand('${layerKey}')">
                            <span class="group-toggle" id="toggle-${layerKey}">‚ñº</span>
                            <input type="checkbox" class="group-checkbox" 
                                   data-layer="${layerKey}" 
                                   ${allVisible ? 'checked' : ''}
                                   ${!allVisible && someVisible ? 'indeterminate' : ''}
                                   onclick="event.stopPropagation(); toggleGroupVisibility('${layerKey}', this.checked)">
                            <span class="group-name">${group.displayName}</span>
                            <span class="group-pct ${groupPctClass}">${groupPct}%</span>
                        </div>
                        <div class="group-children" id="children-${layerKey}">
                `;
                
                for (const zone of group.zones) {
                    const pctClass = getPctClass(zone.coverage_pct);
                    const pctColor = getPctColor(zone.coverage_pct);
                    const isVisible = zoneVisibility[zone.zone_name] !== false;
                    
                    // Extract just the zone number for display (e.g., "Embankment_0" -> "Zone 0")
                    const shortName = zone.zone_name.replace(/^.*_(\d+)$/, 'Zone $1');
                    
                    html += `
                        <div class="stat-row">
                            <input type="checkbox" class="zone-checkbox" 
                                   data-zone="${zone.zone_name}"
                                   data-layer="${layerKey}"
                                   ${isVisible ? 'checked' : ''}
                                   onchange="toggleZoneVisibility('${zone.zone_name}', this.checked); updateGroupCheckbox('${layerKey}');">
                            <span class="zone-name" title="${zone.zone_name}">${shortName}</span>
                            <div class="progress-bar">
                                <div class="progress-fill" style="width: ${Math.min(zone.coverage_pct, 100)}%; background: ${pctColor};"></div>
                            </div>
                            <span class="pct-value ${pctClass}">${zone.coverage_pct}%</span>
                        </div>
                    `;
                }
                
                html += `
                        </div>
                    </div>
                `;
            }
            
            // Add total row (no checkbox for total)
            const totalPctClass = getPctClass(stats.total.coverage_pct);
            html += `
                <div class="stat-row total-row">
                    <span class="zone-name" style="margin-left: 22px;">Total</span>
                    <div class="progress-bar">
                        <div class="progress-fill" style="width: ${Math.min(stats.total.coverage_pct, 100)}%; background: ${getPctColor(stats.total.coverage_pct)};"></div>
                    </div>
                    <span class="pct-value ${totalPctClass}">${stats.total.coverage_pct}%</span>
                </div>
            `;
            
            container.innerHTML = html;
            
            // Set indeterminate state on group checkboxes where applicable
            for (const [layerKey, group] of Object.entries(groupedZones)) {
                updateGroupCheckbox(layerKey);
            }
        }
        
        // Track group expansion state
        const groupExpanded = {};
        
        // Toggle group expand/collapse
        function toggleGroupExpand(layerKey) {
            const children = document.getElementById(`children-${layerKey}`);
            const toggle = document.getElementById(`toggle-${layerKey}`);
            
            if (!children || !toggle) return;
            
            const isExpanded = !children.classList.contains('collapsed');
            
            if (isExpanded) {
                children.classList.add('collapsed');
                toggle.classList.add('collapsed');
                groupExpanded[layerKey] = false;
            } else {
                children.classList.remove('collapsed');
                toggle.classList.remove('collapsed');
                groupExpanded[layerKey] = true;
            }
        }
        
        // Toggle all zones in a group at once
        function toggleGroupVisibility(layerKey, visible) {
            // Find all zone checkboxes in this group
            const checkboxes = document.querySelectorAll(`.zone-checkbox[data-layer="${layerKey}"]`);
            
            checkboxes.forEach(cb => {
                const zoneName = cb.dataset.zone;
                if (zoneVisibility[zoneName] !== visible) {
                    cb.checked = visible;
                    toggleZoneVisibility(zoneName, visible);
                }
            });
        }
        
        // Update group checkbox state based on children
        function updateGroupCheckbox(layerKey) {
            const groupCb = document.querySelector(`.group-checkbox[data-layer="${layerKey}"]`);
            const childCbs = document.querySelectorAll(`.zone-checkbox[data-layer="${layerKey}"]`);
            
            if (!groupCb || childCbs.length === 0) return;
            
            const checkedCount = Array.from(childCbs).filter(cb => cb.checked).length;
            
            if (checkedCount === 0) {
                groupCb.checked = false;
                groupCb.indeterminate = false;
            } else if (checkedCount === childCbs.length) {
                groupCb.checked = true;
                groupCb.indeterminate = false;
            } else {
                groupCb.checked = false;
                groupCb.indeterminate = true;
            }
        }
        
        // Toggle zone visibility - INSTANT using pre-computed zone_ids
        // No server calls, no geometry tests - uses zone_ids from borehole data
        function toggleZoneVisibility(zoneName, visible) {
            console.log(`üîÑ Toggle zone ${zoneName}: ${visible}`);
            
            // 1. Update state
            zoneVisibility[zoneName] = visible;
            
            // 2. Update zone polygon opacity (instant)
            zonesLayer.eachLayer((layer) => {
                const props = layer.feature?.properties;
                if (props && (props.zone_name === zoneName || props.display_name === zoneName)) {
                    if (visible) {
                        layer.setStyle({ opacity: 0.8, fillOpacity: 1 });
                    } else {
                        layer.setStyle({ opacity: 0, fillOpacity: 0 });
                    }
                }
            });
            
            // 3. Update borehole visibility using zone_ids (instant - no geometry tests)
            boreholeMarkers.forEach((grabCircle) => {
                const markerGroup = grabCircle.markerGroup;
                const zoneIds = grabCircle.zoneIds || [];  // Pre-computed from server
                const shouldBeVisible = isBoreholeVisibleByZones(zoneIds);
                
                if (shouldBeVisible) {
                    if (!map.hasLayer(markerGroup)) {
                        boreholesLayer.addLayer(markerGroup);
                    }
                } else {
                    if (map.hasLayer(markerGroup)) {
                        markerGroup.remove();
                    }
                }
            });
            
            // 4. Update coverage visibility (derives from parent borehole)
            coverageLayer.eachLayer((layer) => {
                const props = layer.feature?.properties;
                if (props && props.borehole_index !== undefined) {
                    const parentMarker = boreholeMarkers.find(m => m.boreholeIndex === props.borehole_index);
                    if (parentMarker) {
                        const zoneIds = parentMarker.zoneIds || [];
                        const shouldBeVisible = isBoreholeVisibleByZones(zoneIds);
                        layer.setStyle({
                            opacity: shouldBeVisible ? 0.8 : 0,
                            fillOpacity: shouldBeVisible ? 0.25 : 0
                        });
                    }
                }
            });
            
            // 5. Update count display
            updateBoreholeCountDisplay();
        }
        
        // DEPRECATED: This function was part of the old visibility system that used
        // runtime point-in-polygon tests. It's no longer needed because:
        // 1. Boreholes now have zone_ids pre-computed by the server
        // 2. toggleZoneVisibility() uses zone_ids for instant visibility
        // 3. Coverage visibility derives from parent borehole visibility
        //
        // Kept as no-op for backward compatibility with any existing calls
        async function updateBoreholeVisibilityForZones() {
            console.warn('‚ö†Ô∏è updateBoreholeVisibilityForZones() is deprecated. ' +
                         'Use toggleZoneVisibility() which uses zone_ids for instant updates.');
            // No-op - all visibility logic is now in toggleZoneVisibility()
        }
        
        // Simple point-in-polygon test for GeoJSON geometry
        function isPointInPolygon(point, geometry) {
            if (geometry.type === 'Polygon') {
                return pointInPolygonRing(point, geometry.coordinates[0]);
            } else if (geometry.type === 'MultiPolygon') {
                for (const polygon of geometry.coordinates) {
                    if (pointInPolygonRing(point, polygon[0])) {
                        return true;
                    }
                }
            }
            return false;
        }
        
        // Ray casting algorithm for point in polygon
        function pointInPolygonRing(point, ring) {
            const [x, y] = point;
            let inside = false;
            
            for (let i = 0, j = ring.length - 1; i < ring.length; j = i++) {
                const [xi, yi] = ring[i];
                const [xj, yj] = ring[j];
                
                if (((yi > y) !== (yj > y)) && (x < (xj - xi) * (y - yi) / (yj - yi) + xi)) {
                    inside = !inside;
                }
            }
            
            return inside;
        }
        
        async function updateDataTimestamp() {
            const dataInfo = await fetchDataInfo();
            if (!dataInfo) return;
            
            const container = document.getElementById('dataTimestamp');
            
            if (dataInfo.data_file_modified) {
                // Parse ISO date and format for display
                const modifiedDate = new Date(dataInfo.data_file_modified);
                const formattedDate = modifiedDate.toLocaleString('en-GB', {
                    day: '2-digit',
                    month: 'short',
                    year: 'numeric',
                    hour: '2-digit',
                    minute: '2-digit'
                });
                container.innerHTML = `üìÅ Data from: ${formattedDate}`;
            } else {
                container.innerHTML = '';
            }
            
            // Check for timestamp warning and show alert if files are out of sync
            if (dataInfo.timestamp_warning) {
                const warning = dataInfo.timestamp_warning;
                container.innerHTML += ` <span style="color: #e74c3c; cursor: pointer;" title="Click for details" onclick="showTimestampWarning()">‚ö†Ô∏è ${warning.diff_hours}h diff</span>`;
                
                // Store warning details globally for the popup
                window.timestampWarning = warning;
            }
            
            // Log source files to console for debugging
            if (dataInfo.source_files && dataInfo.source_files.length > 0) {
                console.log('üìÅ Source files:');
                dataInfo.source_files.forEach(f => {
                    console.log(`   ${f.type}: ${f.name} (${f.display})`);
                });
            }
        }
        
        function showTimestampWarning() {
            if (!window.timestampWarning) return;
            const w = window.timestampWarning;
            alert(`‚ö†Ô∏è Source File Timestamp Mismatch\n\n` +
                  `${w.message}\n\n` +
                  `Oldest: ${w.oldest.name}\n  (${w.oldest.display})\n\n` +
                  `Newest: ${w.newest.name}\n  (${w.newest.display})\n\n` +
                  `Recommendation: Re-run main.py to regenerate all files.`);
        }
        
        function renderZones(geojson) {
            zonesLayer.clearLayers();
            zonesLayer.addData(geojson);
            
            // Update info panel
            document.getElementById('zoneCount').textContent = geojson.features.length;
        }
        
        function getBoreholeVisibleRadius() {
            return (CONFIG && CONFIG.boreholeMarker) ? CONFIG.boreholeMarker.visible_radius_m : 8;
        }
        
        function getBoreholeGrabRadius() {
            return (CONFIG && CONFIG.boreholeMarker) ? CONFIG.boreholeMarker.grab_radius_m : 24;
        }
        
        function getBoreholeColor() {
            return (CONFIG && CONFIG.boreholeMarker) ? CONFIG.boreholeMarker.color : '#000000';
        }
        
        function getOutsideZoneColor() {
            return (CONFIG && CONFIG.boreholeMarker) ? CONFIG.boreholeMarker.outside_zone_color : '#FF8C00';
        }
        
        function getOutsideZoneRadiusPx() {
            return (CONFIG && CONFIG.boreholeMarker) ? CONFIG.boreholeMarker.outside_zone_radius_px : 6;
        }
        
        // Check if a point is inside any zone
        function isPointInAnyZone(lon, lat) {
            if (!zonesData || !zonesData.features) return false;
            
            const point = [lon, lat]; // [lon, lat] for GeoJSON
            for (const feature of zonesData.features) {
                if (isPointInPolygon(point, feature.geometry)) {
                    return true;
                }
            }
            return false;
        }
        
        // Create visible marker based on zone membership
        // Inside zone: L.circle (meters, scales with zoom)
        // Outside zone: L.circleMarker (pixels, fixed screen size)
        function createVisibleMarker(latlng, isInsideZone) {
            if (isInsideZone) {
                const visibleRadius = getBoreholeVisibleRadius();
                const markerColor = getBoreholeColor();
                return L.circle(latlng, {
                    radius: visibleRadius,
                    color: markerColor,
                    fillColor: markerColor,
                    fillOpacity: 1,
                    weight: 0,
                    interactive: false
                });
            } else {
                const outsideColor = getOutsideZoneColor();
                const outsideRadiusPx = getOutsideZoneRadiusPx();
                return L.circleMarker(latlng, {
                    radius: outsideRadiusPx,  // pixels
                    color: outsideColor,
                    fillColor: outsideColor,
                    fillOpacity: 1,
                    weight: 0,
                    interactive: false
                });
            }
        }
        
        // Update marker when moving between zones
        // Need to recreate marker if type changes (L.circle <-> L.circleMarker)
        function updateMarkerForZoneChange(grabCircle, lon, lat) {
            const isInsideZone = isPointInAnyZone(lon, lat);
            const wasInsideZone = grabCircle.isInsideZone;
            const latlng = [lat, lon];
            
            // If zone membership changed, recreate the visible marker
            if (isInsideZone !== wasInsideZone) {
                const markerGroup = grabCircle.markerGroup;
                const oldVisibleCircle = grabCircle.visibleCircle;
                
                // Remove old visible marker
                markerGroup.removeLayer(oldVisibleCircle);
                
                // Create new visible marker of correct type
                const newVisibleCircle = createVisibleMarker(latlng, isInsideZone);
                markerGroup.addLayer(newVisibleCircle);
                
                // Update references
                grabCircle.visibleCircle = newVisibleCircle;
                grabCircle.isInsideZone = isInsideZone;
            }
        }
        
        function renderBoreholes(geojson) {
            boreholesLayer.clearLayers();
            boreholeMarkers = [];
            
            const grabRadius = getBoreholeGrabRadius();
            
            geojson.features.forEach((feature, index) => {
                const coords = feature.geometry.coordinates;
                const [lon, lat] = coords;
                const latlng = [lat, lon];
                
                const boreholeId = feature.properties.location_id || `PROP_${index}`;
                
                // Get zone_ids from server (single source of truth)
                const zoneIds = feature.properties.zone_ids || [];
                
                // Check if this borehole should be hidden based on zone visibility
                // Uses pre-computed zone_ids - instant, no geometry tests
                const shouldHide = !isBoreholeVisibleByZones(zoneIds);
                
                // Check zone membership for marker styling
                const isInsideZone = zoneIds.length > 0;
                
                // Create invisible grab circle (larger, for easier dragging)
                const grabCircle = L.circle(latlng, {
                    radius: grabRadius,
                    color: 'transparent',
                    fillColor: 'transparent',
                    fillOpacity: 0,
                    weight: 0,
                    interactive: true,
                    bubblingMouseEvents: false
                });
                
                // Create visible marker based on zone membership
                // Inside zone: L.circle (meters, scales with zoom) - black
                // Outside zone: L.circleMarker (pixels, fixed screen size) - orange
                const visibleCircle = createVisibleMarker(latlng, isInsideZone);
                
                // Group them together
                const markerGroup = L.layerGroup([grabCircle, visibleCircle]);
                
                // Store metadata on grab circle (which handles events)
                grabCircle.boreholeIndex = index;
                grabCircle.boreholeId = boreholeId;
                grabCircle.zoneIds = zoneIds;  // Pre-computed zone associations from server
                grabCircle.visibleCircle = visibleCircle;
                grabCircle.markerGroup = markerGroup;
                grabCircle.isInsideZone = isInsideZone;  // Track zone membership for transitions
                
                // Hover effects for better visual feedback
                const hoverScale = CONFIG?.boreholeMarker?.hover_scale || 2.0;  // From config or default
                let isDragging = false;  // Track drag state for hover effects
                
                grabCircle.on('mouseover', () => {
                    if (!isDragging) {
                        // Get current radius and scale it for hover
                        const currentRadius = grabCircle.visibleCircle.getRadius();
                        grabCircle.visibleCircle.setRadius(currentRadius * hoverScale);
                        map.getContainer().style.cursor = 'grab';
                    }
                });
                
                grabCircle.on('mouseout', () => {
                    if (!isDragging) {
                        // Restore normal radius based on marker type
                        if (grabCircle.isInsideZone) {
                            grabCircle.visibleCircle.setRadius(getBoreholeVisibleRadius());
                        } else {
                            grabCircle.visibleCircle.setRadius(getOutsideZoneRadiusPx());
                        }
                        map.getContainer().style.cursor = '';
                    }
                });
                
                // Custom drag handling
                let dragStartLatLng = null;
                
                grabCircle.on('mousedown', (e) => {
                    if (e.originalEvent.shiftKey) return; // Don't start drag on shift+click
                    
                    isDragging = true;
                    dragStartLatLng = grabCircle.getLatLng();
                    
                    // Save state BEFORE dragging for undo
                    saveStateForUndo();
                    
                    // Disable map dragging
                    map.dragging.disable();
                    
                    // Change cursor
                    map.getContainer().style.cursor = 'grabbing';
                    
                    // Handle mouse move on map
                    map.on('mousemove', onDragMove);
                    map.on('mouseup', onDragEnd);
                });
                
                function onDragMove(e) {
                    if (!isDragging) return;
                    
                    const newLatLng = e.latlng;
                    grabCircle.setLatLng(newLatLng);
                    visibleCircle.setLatLng(newLatLng);
                }
                
                async function onDragEnd(e) {
                    if (!isDragging) return;
                    
                    isDragging = false;
                    map.dragging.enable();
                    map.getContainer().style.cursor = '';
                    
                    // Remove event listeners
                    map.off('mousemove', onDragMove);
                    map.off('mouseup', onDragEnd);
                    
                    const newLatLng = grabCircle.getLatLng();
                    
                    // Only update if position actually changed
                    if (newLatLng.lat !== dragStartLatLng.lat || newLatLng.lng !== dragStartLatLng.lng) {
                        const result = await updateBoreholePosition(
                            grabCircle.boreholeIndex,
                            newLatLng.lng,
                            newLatLng.lat
                        );
                        
                        if (result) {
                            // Update local data
                            boreholesData.features[grabCircle.boreholeIndex].geometry.coordinates = [newLatLng.lng, newLatLng.lat];
                            
                            // Update zone_ids from server (single source of truth)
                            if (result.zone_ids) {
                                grabCircle.zoneIds = result.zone_ids;
                                boreholesData.features[grabCircle.boreholeIndex].properties.zone_ids = result.zone_ids;
                                
                                // Re-evaluate visibility based on new zone associations
                                const shouldBeVisible = isBoreholeVisibleByZones(result.zone_ids);
                                if (!shouldBeVisible) {
                                    // Borehole moved into hidden zone - hide it
                                    grabCircle.markerGroup.remove();
                                    // Also hide its coverage
                                    coverageLayer.eachLayer((layer) => {
                                        if (layer.feature?.properties?.borehole_index === grabCircle.boreholeIndex) {
                                            layer.setStyle({ opacity: 0, fillOpacity: 0 });
                                        }
                                    });
                                    console.log(`üìç Borehole ${grabCircle.boreholeId} moved into hidden zone, now hidden`);
                                }
                            }
                            
                            // Update marker type if zone membership changed (L.circle <-> L.circleMarker)
                            updateMarkerForZoneChange(grabCircle, newLatLng.lng, newLatLng.lat);
                            
                            // Update single coverage polygon (handles null coverage for points outside zones)
                            updateSingleCoverage(grabCircle.boreholeIndex, result.coverage);
                            
                            // Update info panel
                            showBoreholeInfo(grabCircle, result.zone_info);
                            
                            // Update count display
                            updateBoreholeCountDisplay();
                            
                            // Lazy stats update - fetch after short delay for perceived instant response
                            if (result.stats_pending) {
                                setTimeout(() => refreshCoverageStats(), 50);
                            } else if (result.stats) {
                                renderCoverageStats(result.stats);
                            }
                        }
                    }
                }
                
                // Shift+Click to delete
                grabCircle.on('click', async (e) => {
                    if (e.originalEvent.shiftKey) {
                        // Save state for undo before deleting
                        saveStateForUndo();
                        
                        const deletedIndex = grabCircle.boreholeIndex;
                        const result = await deleteBorehole(deletedIndex);
                        if (result && result.success) {
                            // Update local data
                            boreholesData = result.boreholes;
                            
                            // Re-render boreholes with new indices
                            renderBoreholes(boreholesData);
                            
                            // Remove deleted coverage and update indices (efficient - no API call)
                            removeCoverageByIndex(deletedIndex);
                            
                            // Re-apply zone visibility after re-rendering
                            updateBoreholeVisibilityForZones();
                            
                            // Lazy stats update - fetch after a short delay for snappy UI
                            if (result.stats_pending) {
                                // Defer stats computation - UI feels instant, stats update shortly after
                                setTimeout(async () => {
                                    await refreshCoverageStats();
                                }, 50);  // 50ms delay - UI updates first, then stats
                            } else if (result.stats) {
                                renderCoverageStats(result.stats);
                            }
                            
                            console.log(`üóëÔ∏è Deleted borehole ${grabCircle.boreholeId}`);
                        }
                    } else {
                        showBoreholeInfo(grabCircle, null);
                    }
                });
                
                // Only add to map if not in a hidden zone
                if (!shouldHide) {
                    markerGroup.addTo(boreholesLayer);
                }
                boreholeMarkers.push(grabCircle);  // Always store for reference (needed for visibility toggling)
            });
            
            // Update info panel
            document.getElementById('boreholeCount').textContent = geojson.features.length;
        }
        
        function renderCoverages(geojson) {
            coverageLayer.clearLayers();
            coverageLayer.addData(geojson);
        }
        
        function renderExistingCoverage(geojson) {
            existingCoverageLayer.clearLayers();
            if (geojson && geojson.features && geojson.features.length > 0) {
                existingCoverageLayer.addData(geojson);
                
                // Apply style from config (must be after addData since setStyle only affects existing features)
                if (CONFIG && CONFIG.existingCoverageStyle) {
                    const style = CONFIG.existingCoverageStyle;
                    existingCoverageLayer.setStyle({
                        color: style.color || '#27ae60',
                        weight: style.weight || 2,
                        opacity: style.opacity || 0.7,
                        fillColor: style.fill_color || '#2ecc71',
                        fillOpacity: style.fill_opacity || 0.35
                    });
                    console.log(`üé® Applied existing coverage style: fillColor=${style.fill_color}`);
                }
                
                console.log(`‚úÖ Rendered ${geojson.features.length} existing coverage polygons`);
            }
        }
        
        function updateSingleCoverage(boreholeIndex, coverage) {
            // Remove ALL coverages for this borehole (handle potential duplicates)
            const toRemove = [];
            coverageLayer.eachLayer(layer => {
                const props = layer.feature?.properties;
                if (props && props.borehole_index === boreholeIndex) {
                    toRemove.push(layer);
                }
            });
            toRemove.forEach(layer => coverageLayer.removeLayer(layer));
            
            // Add new coverage if valid
            if (coverage && coverage.geometry) {
                coverage.properties = coverage.properties || {};
                coverage.properties.borehole_index = boreholeIndex;
                coverageLayer.addData(coverage);
            }
        }
        
        // Remove coverage by borehole index and reindex remaining coverages
        // Used for delete operation (avoids re-fetching all coverages from server)
        function removeCoverageByIndex(deletedIndex) {
            const toRemove = [];
            const toUpdate = [];
            
            // Find coverage to remove and coverages that need index update
            coverageLayer.eachLayer(layer => {
                const props = layer.feature?.properties;
                if (props && typeof props.borehole_index === 'number') {
                    if (props.borehole_index === deletedIndex) {
                        toRemove.push(layer);
                    } else if (props.borehole_index > deletedIndex) {
                        // This borehole's index will shift down by 1
                        toUpdate.push(layer);
                    }
                }
            });
            
            // Remove deleted borehole's coverage
            toRemove.forEach(layer => coverageLayer.removeLayer(layer));
            
            // Update indices for remaining boreholes (shift down)
            toUpdate.forEach(layer => {
                layer.feature.properties.borehole_index -= 1;
            });
        }
        
        function showBoreholeInfo(marker, zoneInfo) {
            const panel = document.getElementById('selectedBorehole');
            panel.style.display = 'block';
            
            document.getElementById('selectedId').textContent = marker.boreholeId;
            
            if (zoneInfo) {
                const zones = Object.keys(zoneInfo);
                document.getElementById('selectedZone').textContent = zones.join(', ') || 'Outside zones';
                
                const radii = Object.values(zoneInfo);
                document.getElementById('selectedRadius').textContent = 
                    radii.length > 0 ? radii.map(r => `${r}m`).join(', ') : '-';
            } else {
                document.getElementById('selectedZone').textContent = '-';
                document.getElementById('selectedRadius').textContent = '-';
            }
        }
        
        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        // üöÄ INITIALIZATION
        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        
        function applyConfig() {
            // Apply configuration to layer styles and variables
            if (!CONFIG) return;
            
            // Update zone colors from config
            if (CONFIG.zoneColors) {
                zoneColors = CONFIG.zoneColors;
            }
            
            // Update base layer opacity
            if (CONFIG.map && CONFIG.map.base_layer_opacity !== undefined) {
                baseLayer.setOpacity(CONFIG.map.base_layer_opacity);
            }
            
            // Update zone polygon style from config
            if (CONFIG.zonePolygonStyle) {
                const style = CONFIG.zonePolygonStyle;
                zonesLayer.setStyle({
                    color: style.color || '#666666',
                    weight: style.weight || 3,
                    opacity: style.opacity || 0.8,
                    fillColor: style.fill_color || '#ffffff',
                    fillOpacity: style.fill_opacity || 1.0
                });
            }
            
            // Update existing coverage style from config
            if (CONFIG.existingCoverageStyle) {
                const style = CONFIG.existingCoverageStyle;
                existingCoverageLayer.setStyle({
                    color: style.color || '#27ae60',
                    weight: style.weight || 2,
                    opacity: style.opacity || 0.7,
                    fillColor: style.fill_color || '#2ecc71',
                    fillOpacity: style.fill_opacity || 0.35
                });
            }
            
            // Apply coverage panel width from config
            if (CONFIG.ui && CONFIG.ui.coverage_panel_width_px) {
                document.documentElement.style.setProperty(
                    '--coverage-panel-width', 
                    CONFIG.ui.coverage_panel_width_px + 'px'
                );
            }
            
            // Apply progress bar width from config
            if (CONFIG.ui && CONFIG.ui.coverage_progress_bar_width_px) {
                document.documentElement.style.setProperty(
                    '--coverage-progress-bar-width', 
                    CONFIG.ui.coverage_progress_bar_width_px + 'px'
                );
            }
            
            console.log('üìã Config applied:', CONFIG);
        }
        
        async function initialize() {
            const loadingOverlay = document.getElementById('loadingOverlay');
            
            try {
                // Load config first
                CONFIG = await fetchConfig();
                if (CONFIG) {
                    applyConfig();
                }
                
                // Load zones
                zonesData = await fetchZones();
                renderZones(zonesData);
                
                // Load existing coverage (green, from main.py output)
                const existingCoverage = await fetchExistingCoverage();
                renderExistingCoverage(existingCoverage);
                
                // Load boreholes
                boreholesData = await fetchBoreholes();
                originalBoreholesData = JSON.parse(JSON.stringify(boreholesData));  // Save initial state for reset
                renderBoreholes(boreholesData);
                
                // Load initial coverages (blue, proposed) - includes stats for efficiency
                const coveragesResponse = await fetchAllCoverages();
                renderCoverages(coveragesResponse);
                
                // Render coverage stats from the same response (avoids extra API call)
                if (coveragesResponse.stats) {
                    renderCoverageStats(coveragesResponse.stats);
                } else {
                    // Fallback for backward compatibility
                    await refreshCoverageStats();
                }
                
                // Load data timestamp
                await updateDataTimestamp();
                
                // Fit map to zones bounds
                if (zonesLayer.getBounds().isValid()) {
                    map.fitBounds(zonesLayer.getBounds(), { padding: [20, 20] });
                }
                
                console.log('‚úÖ Initialization complete');
                
            } catch (error) {
                console.error('‚ùå Initialization failed:', error);
                alert('Failed to load data. Check console for details.');
            } finally {
                loadingOverlay.style.display = 'none';
            }
        }
        
        // Start initialization
        initialize();
        
        // Toggle base map visibility
        document.getElementById('toggleBaseMap').addEventListener('change', function() {
            if (this.checked) {
                baseLayer.setOpacity(0.25);
            } else {
                baseLayer.setOpacity(0);
            }
        });
        
        // Toggle left panel (Coverage by Zone)
        document.getElementById('leftPanelToggle').addEventListener('click', function() {
            const panel = document.getElementById('leftPanel');
            const toggleBtn = this;
            
            panel.classList.toggle('collapsed');
            toggleBtn.classList.toggle('panel-open');
        });
        
        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        // üîò BUTTON HANDLERS
        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        
        // Undo button
        document.getElementById('undoBtn').addEventListener('click', performUndo);
        
        // Reset button
        document.getElementById('resetBtn').addEventListener('click', performReset);
        
        // Export CSV button - exports only visible boreholes (respects all filters)
        document.getElementById('exportCsvBtn').addEventListener('click', function() {
            // Use generic helper to get hidden boreholes (works with any current/future filter)
            const hiddenIndices = getHiddenBoreholeIndices();
            
            let exportUrl = '/api/boreholes/export';
            if (hiddenIndices.length > 0) {
                const excludeParam = hiddenIndices.join(',');
                exportUrl += `?excludeIndices=${excludeParam}`;
            }
            window.location.href = exportUrl;
        });
        
        // Add borehole button
        document.getElementById('addBoreholeBtn').addEventListener('click', function() {
            addBoreholeMode = !addBoreholeMode;
            
            const btn = this;
            const indicator = document.getElementById('addModeIndicator');
            
            if (addBoreholeMode) {
                btn.classList.add('active');
                btn.textContent = '‚úï Cancel';
                indicator.style.display = 'block';
                map.getContainer().style.cursor = 'crosshair';
            } else {
                btn.classList.remove('active');
                btn.textContent = '+ Add Borehole';
                indicator.style.display = 'none';
                map.getContainer().style.cursor = '';
            }
        });
        
        // ESC key to cancel add mode
        document.addEventListener('keydown', function(e) {
            if (e.key === 'Escape' && addBoreholeMode) {
                document.getElementById('addBoreholeBtn').click();
            }
        });
        
        // Map click handler for adding boreholes
        map.on('click', async function(e) {
            if (!addBoreholeMode) return;
            
            const lat = e.latlng.lat;
            const lon = e.latlng.lng;
            
            // Save state for undo
            saveStateForUndo();
            
            // Add the borehole
            const result = await addNewBorehole(lon, lat);
            
            if (result && result.success) {
                // Update local data
                boreholesData = result.boreholes;
                
                // Re-render all boreholes
                renderBoreholes(boreholesData);
                
                // Add the new coverage
                if (result.coverage) {
                    result.coverage.properties = result.coverage.properties || {};
                    result.coverage.properties.borehole_index = result.index;
                    coverageLayer.addData(result.coverage);
                }
                
                // Re-apply zone visibility after re-rendering
                updateBoreholeVisibilityForZones();
                
                // Render coverage stats from response (fast - avoids extra API call)
                if (result.stats) {
                    renderCoverageStats(result.stats);
                }
                
                console.log(`‚ûï Added borehole at (${lon.toFixed(6)}, ${lat.toFixed(6)})`);
            }
            
            // Exit add mode after adding
            document.getElementById('addBoreholeBtn').click();
        });
    </script>
</body>
</html>
