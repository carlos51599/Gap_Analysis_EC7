# Existing Coverage (Green) Visibility Options Analysis

## Problem Statement

When a zone is hidden:
- **Blue coverage (proposed)**: Already clips/hides correctly via `/api/coverage/filtered`
- **Green coverage (existing)**: Remains fully visible - doesn't respect zone visibility

The green existing coverage is loaded from a static GeoJSON (`covered.geojson`) generated by `main.py`. It's rendered once on initial load without any zone-visibility filtering.

## Current Data Flow

```
main.py
   │
   └─► Output/covered.geojson (single polygon, all-zones combined)
         │
         │ generate_zone_data.py
         ▼
zone_coverage_data.json
   │
   │ "existing_coverage" key
   ▼
/api/existing-coverage
   │
   │ Frontend initial load
   ▼
existingCoverageLayer (L.geoJSON, static, never filtered)
```

## Options Analysis

### Option A: Client-Side Layer Hiding (Fastest Implementation)

**Approach**: Hide the entire `existingCoverageLayer` when ANY zone is hidden.

**Implementation**:
```javascript
// In toggleZoneVisibility():
const hiddenZones = getHiddenZoneNames();
if (hiddenZones.length > 0) {
    map.removeLayer(existingCoverageLayer);
} else {
    existingCoverageLayer.addTo(map);
}
```

**Pros**:
- Trivial to implement (~5 lines)
- Instant, no server calls
- No data duplication

**Cons**:
- All-or-nothing - can't hide just one zone's area
- Not SSOT-compliant (client makes visibility decision)
- Inconsistent with proposed coverage behavior

**SSOT Rating**: ⚠️ Partial (acceptable for MVP if documented)

---

### Option B: Server-Side Clipping on Toggle (Recommended)

**Approach**: Add `/api/existing-coverage/filtered` endpoint that clips to visible zones.

**Implementation**:

1. **Server endpoint** (`server.py`):
```python
@app.route("/api/existing-coverage/filtered", methods=["POST"])
def get_existing_coverage_filtered():
    data = request.get_json()
    exclude_zones = data.get("excludeZones", [])
    
    # Get existing coverage geometry
    existing = data_loader.get_existing_coverage_geojson()
    if not existing:
        return jsonify({"type": "FeatureCollection", "features": []})
    
    # Clip to visible zones using geometry_service
    clipped = coverage_service.clip_to_visible_zones(existing, exclude_zones)
    return jsonify(clipped)
```

2. **Frontend** (`index.html`):
```javascript
// In toggleZoneVisibility():
const hiddenZones = getHiddenZoneNames();
if (hiddenZones.length === 0) {
    const existing = await fetchExistingCoverage();
    renderExistingCoverage(existing);
} else {
    const clipped = await fetchFilteredExistingCoverage(hiddenZones);
    renderExistingCoverage(clipped);
}
```

**Pros**:
- SSOT-compliant (server decides what to return)
- Consistent with proposed coverage behavior
- Exact same UX as blue coverage

**Cons**:
- Requires new endpoint
- ~200-300ms server delay (same as proposed coverage)
- More complex implementation

**SSOT Rating**: ✅ Full compliance

---

### Option C: Pre-Split at Data Generation Time

**Approach**: During `generate_zone_data.py`, split existing coverage into per-zone features.

**Implementation**:

1. **Data generation** (`generate_zone_data.py`):
```python
def split_existing_coverage_by_zone(existing_gdf, zones_gdf):
    """Split existing coverage into per-zone features."""
    results = []
    for _, zone in zones_gdf.iterrows():
        zone_name = zone.zone_name
        clipped = existing_gdf.geometry.intersection(zone.geometry)
        if not clipped.is_empty:
            results.append({
                "geometry": clipped,
                "zone_name": zone_name
            })
    return results
```

2. **zone_coverage_data.json**:
```json
{
    "existing_coverage": {
        "features": [
            {"properties": {"zone_name": "Embankment_0"}, "geometry": {...}},
            {"properties": {"zone_name": "Embankment_1"}, "geometry": {...}},
            ...
        ]
    }
}
```

3. **Frontend**: Filter features by `zone_name` property on toggle.

**Pros**:
- Data pre-split (no runtime clipping)
- Fast toggle (filter features client-side)
- Simpler server endpoint (just serve pre-split data)

**Cons**:
- Increased JSON file size (polygon duplication at boundaries)
- Requires re-running `generate_zone_data.py`
- Client-side filtering (partial SSOT)

**SSOT Rating**: ⚠️ Partial (data computed server-side, filtering client-side)

---

### Option D: Hybrid - Pre-Split + Server-Serve

**Approach**: Pre-split during generation, server filters before sending.

**Implementation**:
- `generate_zone_data.py` splits coverage by zone (like Option C)
- Server endpoint filters to exclude hidden zones before responding
- Frontend just renders what server returns

**Pros**:
- No runtime clipping (fast)
- Fully SSOT (server decides)
- Clean separation

**Cons**:
- Requires re-running data generation
- Slight increase in stored data size

**SSOT Rating**: ✅ Full compliance

---

## Recommendation Matrix

| Option | SSOT | Performance | Complexity | Recommendation |
|--------|------|-------------|------------|----------------|
| A (Client Hide) | Partial | Instant | Trivial | Quick fix only |
| B (Server Clip) | Full | ~200ms | Medium | **Recommended** |
| C (Pre-Split) | Partial | Fast | Medium | Not recommended |
| D (Hybrid) | Full | Fast | Medium | Best long-term |

## Recommended Approach: Option B (Server Clipping)

**Rationale**:
1. **Consistency**: Same pattern as proposed coverage clipping
2. **SSOT**: Server makes all visibility decisions
3. **No data changes**: Works with existing `zone_coverage_data.json`
4. **User expectation**: ~200ms delay is already acceptable for proposed coverage

**Implementation Steps**:
1. Add `clip_to_visible_zones()` method to `geometry_service.py`
2. Add `/api/existing-coverage/filtered` endpoint to `server.py`
3. Add `fetchFilteredExistingCoverage()` function to frontend
4. Update `toggleZoneVisibility()` to call new endpoint

**Future Optimization (Option D)**:
If performance becomes an issue, migrate to pre-split approach:
1. Update `generate_zone_data.py` to split existing coverage by zone
2. Modify endpoint to filter by zone_name instead of clipping
3. No frontend changes needed
